<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PoLP Attack Surface Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 380px 1fr;
            height: 100vh;
        }

        .control-panel {
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            padding: 20px;
            border-right: 2px solid #333;
            overflow-y: auto;
        }

        .visualization {
            position: relative;
            background: radial-gradient(circle at center, #0f0f23 0%, #000000 100%);
        }

        .zoom-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.3s ease;
        }

        .zoom-btn:hover {
            background: rgba(0, 212, 170, 0.8);
            transform: scale(1.1);
        }

        h1 {
            color: #00d4aa;
            margin-bottom: 20px;
            font-size: 1.4em;
            text-align: center;
        }

        .section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
        }

        .section h3 {
            color: #00d4aa;
            margin-bottom: 12px;
            font-size: 1em;
        }

        .metrics {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 2px solid #e74c3c;
        }

        .metric-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.9em;
            color: #ecf0f1;
        }

        .metric-value {
            font-weight: bold;
            color: #fff;
        }

        .form-group {
            margin-bottom: 12px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
            font-size: 0.85em;
        }

        select, input[type="text"] {
            width: 100%;
            padding: 6px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: #fff;
            font-size: 0.85em;
        }

        select option {
            background: #1a1a2e;
            color: #fff;
        }

        .access-groups {
            max-height: 300px;
            overflow-y: auto;
        }

        .group-item {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            position: relative;
        }

        .group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .group-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #fff;
        }

        .group-name {
            font-weight: bold;
            font-size: 0.9em;
        }

        .delete-group {
            background: #ff4757;
            border: none;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
        }

        .group-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 0.8em;
        }

        .group-controls select {
            padding: 4px;
            font-size: 0.8em;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }

        .preset-btn {
            padding: 6px 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 0.75em;
            transition: all 0.3s ease;
        }

        .preset-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
        }

        .movement-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        button {
            padding: 8px 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .warning {
            background: linear-gradient(135deg, #ff9500 0%, #ff5722 100%);
            padding: 8px;
            border-radius: 5px;
            margin-top: 8px;
            animation: pulse 2s infinite;
            font-size: 0.85em;
        }

        .critical-warning {
            background: linear-gradient(135deg, #ff4757 0%, #c44569 100%);
            padding: 8px;
            border-radius: 5px;
            margin-top: 8px;
            animation: pulse 1s infinite;
            font-size: 0.85em;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .reset-btn {
            background: linear-gradient(135deg, #ff4757 0%, #c44569 100%);
            width: 100%;
            margin-top: 15px;
            padding: 10px;
        }

        .add-group-btn {
            background: linear-gradient(135deg, #00d4aa 0%, #01a3a4 100%);
            width: 100%;
            margin-bottom: 10px;
            padding: 8px;
        }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.85em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 3px;
        }

        .node-label {
            fill: white;
            font-size: 11px;
            text-anchor: middle;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .asset {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .asset:hover {
            stroke-width: 4px;
            filter: brightness(1.2);
        }

        .store {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .store:hover {
            stroke-width: 4px;
            filter: brightness(1.2);
        }

        .asset-controls {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            min-width: 250px;
            z-index: 1000;
            display: none;
        }

        .asset-controls h4 {
            color: #00d4aa;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .checkbox-group {
            max-height: 120px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 5px;
            margin-bottom: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.8em;
        }

        .checkbox-item input[type="checkbox"] {
            margin-right: 8px;
            width: auto;
        }

        .close-controls {
            position: absolute;
            top: 5px;
            right: 8px;
            background: none;
            border: none;
            color: #fff;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            width: 20px;
            height: 20px;
        }

        .violation-indicator {
            position: absolute;
            pointer-events: none;
            z-index: 999;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            max-width: 250px;
        }

        .tooltip-header {
            font-weight: bold;
            color: #00d4aa;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 3px;
        }

        .tooltip-content {
            line-height: 1.4;
        }

        .tooltip-hint {
            margin-top: 8px;
            padding-top: 5px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-style: italic;
            color: #bdc3c7;
            font-size: 11px;
        }

        .error-message {
            background: #ff4757;
            color: white;
            padding: 8px;
            border-radius: 4px;
            margin: 5px 0;
            font-size: 0.85em;
            display: none;
        }

        .success-message {
            background: #2ecc71;
            color: white;
            padding: 8px;
            border-radius: 4px;
            margin: 5px 0;
            font-size: 0.85em;
            display: none;
        }

        .copy-link {
            stroke: #74b9ff;
            stroke-width: 2;
            stroke-dasharray: 5,5;
            stroke-opacity: 0.6;
            animation: dashFlow 2s linear infinite;
        }

        @keyframes dashFlow {
            to {
                stroke-dashoffset: -10;
            }
        }

        .shortcuts-help {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 15px;
            border-radius: 8px;
            font-size: 0.8em;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            max-width: 300px;
            z-index: 1001;
        }

        .shortcuts-help.show {
            opacity: 1;
            transform: translateY(0);
        }

        .shortcuts-help h4 {
            color: #00d4aa;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .shortcuts-help .close-shortcuts {
            background: none;
            border: none;
            color: #fff;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .shortcuts-help .close-shortcuts:hover {
            opacity: 1;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .shortcut-key {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.9em;
            min-width: 60px;
            text-align: center;
        }

        .shortcut-desc {
            color: #ccc;
            margin-left: 10px;
            flex: 1;
        }

        .violation-popup {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ff4757;
            border-radius: 8px;
            padding: 15px;
            max-width: 400px;
            z-index: 1002;
            color: white;
            font-size: 0.85em;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
        }

        .violation-popup h4 {
            color: #ff4757;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .violation-popup .close-popup {
            background: none;
            border: none;
            color: #fff;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .violation-popup .close-popup:hover {
            opacity: 1;
        }

        .violation-details {
            margin-bottom: 10px;
            line-height: 1.4;
        }

        .violation-recommendation {
            background: rgba(0, 212, 170, 0.1);
            border-left: 3px solid #00d4aa;
            padding: 8px;
            margin-top: 10px;
            border-radius: 0 4px 4px 0;
        }

        .violation-recommendation strong {
            color: #00d4aa;
        }

        .undo-redo-controls {
            position: absolute;
            top: 130px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
        }

        .undo-redo-btn {
            width: 40px;
            height: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .undo-redo-btn:hover:not(:disabled) {
            background: rgba(0, 212, 170, 0.8);
            transform: scale(1.05);
        }

        .undo-redo-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="control-panel">
            <h1>🛡️ PoLP Visualizer</h1>
            
            <div class="section metrics">
                <h3>📊 PoLP Metrics</h3>
                <div class="metric-item">
                    <span>Total People with Access:</span>
                    <span id="totalPeople" class="metric-value">0</span>
                </div>
                <div style="margin-left: 15px; font-size: 0.8em; color: #bdc3c7;">
                    <div class="metric-item" style="margin-bottom: 4px;">
                        <span>📋 Unclassified:</span>
                        <span id="unclassifiedPeople" class="metric-value">0</span>
                    </div>
                    <div class="metric-item" style="margin-bottom: 4px;">
                        <span>🏢 Internal:</span>
                        <span id="internalPeople" class="metric-value">0</span>
                    </div>
                    <div class="metric-item" style="margin-bottom: 4px;">
                        <span>🔐 Confidential:</span>
                        <span id="confidentialPeople" class="metric-value">0</span>
                    </div>
                    <div class="metric-item" style="margin-bottom: 4px;">
                        <span>🚫 Restricted:</span>
                        <span id="restrictedPeople" class="metric-value">0</span>
                    </div>
                </div>
                <div class="metric-item">
                    <span>Data Classification Violations:</span>
                    <span id="classificationViolations" class="metric-value">0</span>
                </div>
                <div class="metric-item">
                    <span>Mixed Classification Stores:</span>
                    <span id="mixedStores" class="metric-value">0</span>
                </div>
                <div class="metric-item">
                    <span>Data Asset Copies:</span>
                    <span id="dataCopies" class="metric-value">1</span>
                </div>
                <div class="metric-item">
                    <span>Management Complexity:</span>
                    <span id="managementComplexity" class="metric-value">LOW</span>
                </div>
                <div id="warningMessage"></div>
            </div>

            <div class="section">
                <h3>🗄️ Data Stores</h3>
                <button class="add-group-btn" onclick="addNewDataStore()">+ Add Data Store</button>
                
                <div class="form-group">
                    <label>Store Classification Level:</label>
                    <select id="newStoreClassification">
                        <option value="unclassified">📋 Unclassified (Public)</option>
                        <option value="internal">🏢 Internal Only</option>
                        <option value="confidential" selected>🔐 Confidential</option>
                        <option value="restricted">🚫 Restricted</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Store Name:</label>
                    <input type="text" id="newStoreName" placeholder="e.g., HR Database, Dev Environment">
                </div>
                
                <div id="storeErrorMessage" class="error-message"></div>
                <div id="storeSuccessMessage" class="success-message"></div>
                
                <p style="font-size: 0.8em; color: #ccc; margin-bottom: 15px;">
                    💡 Tip: Drag assets between stores. Ctrl+drag to separate asset into new store. Right-click stores to edit.
                </p>
            </div>

            <div class="section">
                <h3>👥 Access Groups</h3>
                <button class="add-group-btn" onclick="addNewGroup()">+ Add Access Group</button>
                
                <div class="preset-buttons">
                    <button class="preset-btn" onclick="addPresetGroup('executives')">👔 Executives</button>
                    <button class="preset-btn" onclick="addPresetGroup('allstaff')">🏢 All Staff</button>
                    <button class="preset-btn" onclick="addPresetGroup('itteam')">💻 IT Team</button>
                    <button class="preset-btn" onclick="addPresetGroup('contractors')">🤝 Contractors</button>
                    <button class="preset-btn" onclick="addPresetGroup('world')" style="background: linear-gradient(135deg, #ff4757 0%, #c44569 100%);" title="5.7 billion people with access!">🌍 World</button>
                </div>

                <div id="accessGroups" class="access-groups">
                    <!-- Groups will be dynamically added here -->
                </div>
            </div>

            <div class="section">
                <h3>📤 Data Movement Operations</h3>
                <p style="font-size: 0.8em; color: #ccc; margin-bottom: 10px;">
                    Simulate common data operations that can lead to PoLP violations:
                </p>
                <div class="movement-buttons">
                    <button onclick="addDataMovement('backup')">📦 Create Backup</button>
                    <button onclick="addDataMovement('sharing')">🤝 Share with Team</button>
                    <button onclick="addDataMovement('analytics')">📈 Analytics Copy</button>
                    <button onclick="addDataMovement('development')">💻 Dev/Test Copy</button>
                    <button onclick="addDataMovement('cloud')">☁️ Cloud Migration</button>
                    <button onclick="addDataMovement('partner')">🔗 Partner Access</button>
                </div>
            </div>

            <div class="section">
                <h3>🎛️ Actions</h3>
                <button class="add-group-btn" onclick="loadDemo()" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); margin-bottom: 10px;">🎯 Load PoLP Demo Scenario</button>
                <button onclick="exportConfiguration()" style="background: linear-gradient(135deg, #3742fa 0%, #2f3542 100%); width: 100%; margin-bottom: 5px;">💾 Export Configuration</button>
                <button onclick="document.getElementById('importFile').click()" style="background: linear-gradient(135deg, #2ed573 0%, #1e3799 100%); width: 100%; margin-bottom: 10px;">📂 Import Configuration</button>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importConfiguration(event)">
                <button class="reset-btn" onclick="resetVisualization()">🔄 Reset to Single Asset</button>
            </div>
        </div>

        <div class="visualization">
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()" title="Zoom In (+)">+</button>
                <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out (-)">−</button>
                <button class="zoom-btn" onclick="resetZoom()" title="Reset Zoom (0)">⌂</button>
            </div>
            
            <div class="undo-redo-controls">
                <button class="undo-redo-btn" id="undoBtn" onclick="undo()" title="Undo (Ctrl+Z)">↶</button>
                <button class="undo-redo-btn" id="redoBtn" onclick="redo()" title="Redo (Ctrl+Y)">↷</button>
            </div>
            
            <div id="assetControls" class="asset-controls">
                <button class="close-controls" onclick="closeAssetControls()">×</button>
                <h4 id="assetControlsTitle">Asset Configuration</h4>
                
                <div class="form-group">
                    <label>Asset Name:</label>
                    <input type="text" id="assetName" onchange="updateSelectedAsset('label', this.value)">
                </div>
                
                <div class="form-group">
                    <label>Classification:</label>
                    <select id="assetClassification" onchange="updateSelectedAsset('classification', this.value)">
                        <option value="unclassified">📋 Unclassified</option>
                        <option value="internal">🏢 Internal</option>
                        <option value="confidential">🔐 Confidential</option>
                        <option value="restricted">🚫 Restricted</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Access Groups:</label>
                    <div id="assetAccessGroups" class="checkbox-group">
                        <!-- Checkboxes will be populated here -->
                    </div>
                </div>
                
                <button onclick="separateAsset()" style="background: #f39c12; width: 100%; margin-bottom: 5px;">📤 Separate to New Store</button>
                <button onclick="deleteSelectedAsset()" style="background: #ff4757; width: 100%;">🗑️ Delete Asset</button>
            </div>
            
            <div id="storeControls" class="asset-controls">
                <button class="close-controls" onclick="closeStoreControls()">×</button>
                <h4 id="storeControlsTitle">Store Configuration</h4>
                
                <div class="form-group">
                    <label>Store Name:</label>
                    <input type="text" id="storeName" onchange="updateSelectedStore('label', this.value)">
                </div>
                
                <div class="form-group">
                    <label>Classification:</label>
                    <select id="storeClassification" onchange="updateSelectedStore('classification', this.value)">
                        <option value="unclassified">📋 Unclassified</option>
                        <option value="internal">🏢 Internal</option>
                        <option value="confidential">🔐 Confidential</option>
                        <option value="restricted">🚫 Restricted</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Assets in Store:</label>
                    <div id="storeAssetsList" style="max-height: 100px; overflow-y: auto; font-size: 0.8em; color: #ccc;">
                        <!-- Asset list will be populated here -->
                    </div>
                </div>
                
                <button onclick="deleteSelectedStore()" style="background: #ff4757; width: 100%;">🗑️ Delete Store</button>
            </div>
            
            <div id="tooltip" class="tooltip"></div>
            <svg id="networkSvg"></svg>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #2ecc71;"></div>
                    <span>📋 Unclassified</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #3498db;"></div>
                    <span>🏢 Internal</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f39c12;"></div>
                    <span>🔐 Confidential</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #e74c3c;"></div>
                    <span>🚫 Restricted</span>
                </div>
                <div style="margin-top: 10px; font-size: 0.8em;">
                    <div>⚠️ = PoLP Violation</div>
                    <div>🔥 = Critical Risk</div>
                    <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2);">
                        Press <kbd style="background: rgba(255,255,255,0.1); padding: 2px 4px; border-radius: 2px;">H</kbd> for shortcuts
                    </div>
                </div>
            </div>
            
            <div id="shortcutsHelp" class="shortcuts-help">
                <h4>
                    Keyboard Shortcuts
                    <button class="close-shortcuts" onclick="hideShortcuts()">×</button>
                </h4>
                <div class="shortcut-item">
                    <span class="shortcut-key">H</span>
                    <span class="shortcut-desc">Toggle this help</span>
                </div>
                <div class="shortcut-item">
                    <span class="shortcut-key">+</span>
                    <span class="shortcut-desc">Zoom in</span>
                </div>
                <div class="shortcut-item">
                    <span class="shortcut-key">-</span>
                    <span class="shortcut-desc">Zoom out</span>
                </div>
                <div class="shortcut-item">
                    <span class="shortcut-key">0</span>
                    <span class="shortcut-desc">Reset zoom</span>
                </div>
                <div class="shortcut-item">
                    <span class="shortcut-key">R</span>
                    <span class="shortcut-desc">Reset visualization</span>
                </div>
                <div class="shortcut-item">
                    <span class="shortcut-key">D</span>
                    <span class="shortcut-desc">Load demo</span>
                </div>
                <div class="shortcut-item">
                    <span class="shortcut-key">Ctrl+Z</span>
                    <span class="shortcut-desc">Undo</span>
                </div>
                <div class="shortcut-item">
                    <span class="shortcut-key">Ctrl+Y</span>
                    <span class="shortcut-desc">Redo</span>
                </div>
                <div class="shortcut-item">
                    <span class="shortcut-key">Esc</span>
                    <span class="shortcut-desc">Close dialogs</span>
                </div>
                <div class="shortcut-item">
                    <span class="shortcut-key">Ctrl+Drag</span>
                    <span class="shortcut-desc">Separate asset</span>
                </div>
            </div>
            
            <div id="violationPopup" class="violation-popup" style="display: none;">
                <h4 id="violationTitle">
                    Violation Details
                    <button class="close-popup" onclick="closeViolationPopup()">×</button>
                </h4>
                <div id="violationContent" class="violation-details"></div>
                <div id="violationRecommendation" class="violation-recommendation"></div>
            </div>
        </div>
    </div>

    <script>
        // Clean, simplified PoLP Visualizer implementation
        class PolpVisualizer {
            constructor() {
                // Core data structures
                this.stores = new Map();
                this.assets = new Map();
                this.groups = new Map();
                this.links = new Map();
                
                // Counters for unique IDs
                this.nextStoreId = 1;
                this.nextAssetId = 1;
                this.nextGroupId = 1;
                this.nextLinkId = 1;
                
                // UI state
                this.selectedAssetId = null;
                this.selectedStoreId = null;
                this.isCtrlPressed = false;
                
                // Undo/Redo system
                this.history = [];
                this.historyIndex = -1;
                this.maxHistorySize = 50;
                
                // D3 setup
                this.setupD3();
                
                // Configuration
                this.setupConstants();
                
                // Initialize with basic data
                this.initialize();
            }
            
            setupD3() {
                this.svg = d3.select('#networkSvg');
                this.width = window.innerWidth - 380;
                this.height = window.innerHeight;
                
                this.svg.attr('width', this.width).attr('height', this.height);
                
                this.zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        this.g.attr('transform', event.transform);
                    });
                
                this.svg.call(this.zoom);
                this.g = this.svg.append('g');
            }
            
            setupConstants() {
                this.groupColors = [
                    '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', 
                    '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43'
                ];
                
                this.classificationColors = {
                    unclassified: '#2ecc71',
                    internal: '#3498db', 
                    confidential: '#f39c12',
                    restricted: '#e74c3c'
                };
                
                this.classificationIcons = {
                    unclassified: '📋',
                    internal: '🏢',
                    confidential: '🔐',
                    restricted: '🚫'
                };
                
                this.classificationLevels = {
                    unclassified: 0,
                    internal: 1,
                    confidential: 2,
                    restricted: 3
                };
                
                this.accessLevels = {
                    individual: { people: 1, complexity: 1 },
                    team: { people: 8, complexity: 2 },
                    department: { people: 25, complexity: 4 },
                    company: { people: 150, complexity: 8 },
                    external: { people: 10, complexity: 6 },
                    world: { people: 5700000000, complexity: 20 } // 5.7 billion people
                };
                
                this.presetGroups = {
                    executives: {
                        name: 'Executive Team',
                        access: 'team',
                        permission: 'admin',
                        location: 'anywhere',
                        duration: 'permanent'
                    },
                    allstaff: {
                        name: 'All Staff',
                        access: 'company',
                        permission: 'read',
                        location: 'office',
                        duration: 'permanent'
                    },
                    itteam: {
                        name: 'IT Team',
                        access: 'team',
                        permission: 'admin',
                        location: 'office',
                        duration: 'permanent'
                    },
                    contractors: {
                        name: 'External Contractors',
                        access: 'external',
                        permission: 'read',
                        location: 'vpn',
                        duration: 'temporary'
                    },
                    world: {
                        name: 'World (read)',
                        access: 'world',
                        permission: 'read',
                        location: 'anywhere',
                        duration: 'permanent'
                    }
                };
                
                this.movementTemplates = {
                    backup: { label: 'Backup Copy', classification: 'confidential' },
                    sharing: { label: 'Shared Copy', classification: 'internal' },
                    analytics: { label: 'Analytics Copy', classification: 'internal' },
                    development: { label: 'Dev Copy', classification: 'unclassified' },
                    cloud: { label: 'Cloud Copy', classification: 'confidential' },
                    partner: { label: 'Partner Copy', classification: 'internal' }
                };
            }
            
            // Core data management
            createStore(label, classification, x = null, y = null) {
                const id = `store_${this.nextStoreId++}`;
                const store = {
                    id,
                    label,
                    classification,
                    x: x || Math.random() * (this.width * 0.6) + (this.width * 0.2),
                    y: y || Math.random() * (this.height * 0.6) + (this.height * 0.2),
                    assetIds: new Set()
                };
                this.stores.set(id, store);
                return store;
            }
            
            createAsset(label, classification, storeId, accessGroups = []) {
                const id = `asset_${this.nextAssetId++}`;
                const store = this.stores.get(storeId);
                
                const asset = {
                    id,
                    label,
                    classification,
                    storeId,
                    accessGroups: new Set(accessGroups),
                    x: store ? store.x : this.width / 2,
                    y: store ? store.y : this.height / 2,
                    isOriginal: true
                };
                
                this.assets.set(id, asset);
                
                if (store) {
                    store.assetIds.add(id);
                    this.positionAssetsInStore(store);
                }
                
                return asset;
            }
            
            createGroup(name, access, permission, location, duration, color = null) {
                const id = `group_${this.nextGroupId++}`;
                const group = {
                    id,
                    name,
                    access,
                    permission,
                    location,
                    duration,
                    color: color || this.groupColors[(this.nextGroupId - 2) % this.groupColors.length]
                };
                this.groups.set(id, group);
                return group;
            }
            
            createLink(sourceId, targetId, type = 'copy') {
                const id = `link_${this.nextLinkId++}`;
                const link = {
                    id,
                    sourceId,
                    targetId,
                    type
                };
                this.links.set(id, link);
                return link;
            }
            
            // Undo/Redo system
            saveState(description = 'Action') {
                // Create a deep copy of current state
                const state = {
                    description,
                    timestamp: Date.now(),
                    stores: this.serializeStores(),
                    assets: this.serializeAssets(),
                    groups: this.serializeGroups(),
                    links: this.serializeLinks(),
                    counters: {
                        nextStoreId: this.nextStoreId,
                        nextAssetId: this.nextAssetId,
                        nextGroupId: this.nextGroupId,
                        nextLinkId: this.nextLinkId
                    }
                };
                
                // Remove future history if we're not at the end
                this.history = this.history.slice(0, this.historyIndex + 1);
                
                // Add new state
                this.history.push(state);
                this.historyIndex++;
                
                // Limit history size
                if (this.history.length > this.maxHistorySize) {
                    this.history.shift();
                    this.historyIndex--;
                }
                
                this.updateUndoRedoButtons();
            }
            
            serializeStores() {
                return Array.from(this.stores.values()).map(store => ({
                    ...store,
                    assetIds: Array.from(store.assetIds)
                }));
            }
            
            serializeAssets() {
                return Array.from(this.assets.values()).map(asset => ({
                    ...asset,
                    accessGroups: Array.from(asset.accessGroups)
                }));
            }
            
            serializeGroups() {
                return Array.from(this.groups.values());
            }
            
            serializeLinks() {
                return Array.from(this.links.values());
            }
            
            restoreState(state) {
                // Clear current data
                this.stores.clear();
                this.assets.clear();
                this.groups.clear();
                this.links.clear();
                
                // Restore stores
                state.stores.forEach(store => {
                    const restoredStore = { ...store, assetIds: new Set(store.assetIds) };
                    this.stores.set(store.id, restoredStore);
                });
                
                // Restore assets
                state.assets.forEach(asset => {
                    const restoredAsset = { ...asset, accessGroups: new Set(asset.accessGroups) };
                    this.assets.set(asset.id, restoredAsset);
                });
                
                // Restore groups
                state.groups.forEach(group => {
                    this.groups.set(group.id, group);
                });
                
                // Restore links
                state.links.forEach(link => {
                    this.links.set(link.id, link);
                });
                
                // Restore counters
                if (state.counters) {
                    this.nextStoreId = state.counters.nextStoreId;
                    this.nextAssetId = state.counters.nextAssetId;
                    this.nextGroupId = state.counters.nextGroupId;
                    this.nextLinkId = state.counters.nextLinkId;
                }
                
                this.closeAllControls();
                this.renderAccessGroups();
                this.updateVisualization();
                this.updateUndoRedoButtons();
            }
            
            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.restoreState(this.history[this.historyIndex]);
                    this.showMessage(`Undo: ${this.history[this.historyIndex + 1]?.description || 'Action'}`, 'success');
                }
            }
            
            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.restoreState(this.history[this.historyIndex]);
                    this.showMessage(`Redo: ${this.history[this.historyIndex]?.description || 'Action'}`, 'success');
                }
            }
            
            updateUndoRedoButtons() {
                const undoBtn = document.getElementById('undoBtn');
                const redoBtn = document.getElementById('redoBtn');
                
                if (undoBtn) {
                    undoBtn.disabled = this.historyIndex <= 0;
                    undoBtn.title = this.historyIndex > 0 ? 
                        `Undo: ${this.history[this.historyIndex]?.description || 'Action'} (Ctrl+Z)` : 
                        'Nothing to undo (Ctrl+Z)';
                }
                
                if (redoBtn) {
                    redoBtn.disabled = this.historyIndex >= this.history.length - 1;
                    redoBtn.title = this.historyIndex < this.history.length - 1 ? 
                        `Redo: ${this.history[this.historyIndex + 1]?.description || 'Action'} (Ctrl+Y)` : 
                        'Nothing to redo (Ctrl+Y)';
                }
            }
            
            // Keyboard shortcuts
            handleKeyboardShortcut(event) {
                // Don't trigger shortcuts when typing in inputs
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'SELECT' || event.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                const key = event.key.toLowerCase();
                const ctrlOrCmd = event.ctrlKey || event.metaKey;
                
                switch (key) {
                    case 'h':
                        event.preventDefault();
                        this.toggleShortcutsHelp();
                        break;
                    case '+':
                    case '=':
                        event.preventDefault();
                        this.zoomIn();
                        break;
                    case '-':
                        event.preventDefault();
                        this.zoomOut();
                        break;
                    case '0':
                        event.preventDefault();
                        this.resetZoom();
                        break;
                    case 'r':
                        if (!ctrlOrCmd) {
                            event.preventDefault();
                            this.resetVisualization();
                        }
                        break;
                    case 'd':
                        if (!ctrlOrCmd) {
                            event.preventDefault();
                            this.loadDemo();
                        }
                        break;
                    case 'z':
                        if (ctrlOrCmd) {
                            event.preventDefault();
                            if (event.shiftKey) {
                                this.redo();
                            } else {
                                this.undo();
                            }
                        }
                        break;
                    case 'y':
                        if (ctrlOrCmd) {
                            event.preventDefault();
                            this.redo();
                        }
                        break;
                    case 'escape':
                        this.closeAllControls();
                        this.closeViolationPopup();
                        this.hideShortcutsHelp();
                        break;
                }
            }
            
            toggleShortcutsHelp() {
                const help = document.getElementById('shortcutsHelp');
                if (help.classList.contains('show')) {
                    this.hideShortcutsHelp();
                } else {
                    this.showShortcutsHelp();
                }
            }
            
            showShortcutsHelp() {
                const help = document.getElementById('shortcutsHelp');
                help.classList.add('show');
                
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    this.hideShortcutsHelp();
                }, 10000);
            }
            
            hideShortcutsHelp() {
                const help = document.getElementById('shortcutsHelp');
                help.classList.remove('show');
            }
            
            // Violation popup system
            showViolationPopup(violation, event) {
                const popup = document.getElementById('violationPopup');
                const title = document.getElementById('violationTitle');
                const content = document.getElementById('violationContent');
                const recommendation = document.getElementById('violationRecommendation');
                
                // Set content
                title.innerHTML = `${violation.severity === 'CRITICAL' ? '🔥' : '⚠️'} ${violation.type.toUpperCase()} VIOLATION <button class="close-popup" onclick="closeViolationPopup()">×</button>`;
                content.innerHTML = violation.description;
                recommendation.innerHTML = `<strong>💡 Recommendation:</strong><br>${violation.recommendation}`;
                
                // CORRECTED POSITIONING: Apply the same fix as other popups
                const violationElement = event.target;
                if (violationElement && violationElement.getBoundingClientRect) {
                    const elementRect = violationElement.getBoundingClientRect();
                    
                    // Apply the same offset correction
                    const offsetCorrection = 347; // Same correction used for other popups
                    
                    let left = elementRect.right + 15 - offsetCorrection;
                    let top = elementRect.top - 10;
                    
                    // Keep popup within viewport bounds
                    const popupWidth = 400;
                    const popupHeight = 200;
                    
                    if (left + popupWidth > window.innerWidth) {
                        left = elementRect.left - popupWidth - 15 - offsetCorrection;
                    }
                    if (top + popupHeight > window.innerHeight) {
                        top = elementRect.bottom + 10;
                    }
                    if (top < 20) {
                        top = 20;
                    }
                    
                    // Ensure minimum distance from edges and control panel
                    left = Math.max(400, Math.min(left, window.innerWidth - popupWidth - 20)); // 400 to clear the control panel
                    top = Math.max(20, Math.min(top, window.innerHeight - popupHeight - 20));
                    
                    popup.style.left = left + 'px';
                    popup.style.top = top + 'px';
                    popup.style.display = 'block';
                    
                    console.log('VIOLATION POPUP CORRECTED - Element x:', elementRect.x, 'Corrected left:', left, 'Final position:', left, top);
                } else {
                    // Fallback positioning using the original event coordinates with correction
                    let left = Math.min(event.pageX + 10, window.innerWidth - 400 - 20) - offsetCorrection;
                    let top = Math.min(event.pageY + 10, window.innerHeight - 200 - 20);
                    
                    left = Math.max(400, left); // Ensure it clears the control panel
                    top = Math.max(20, top);
                    
                    popup.style.left = left + 'px';
                    popup.style.top = top + 'px';
                    popup.style.display = 'block';
                    
                    console.log('VIOLATION POPUP FALLBACK positioning used');
                }
                
                // Auto-close after 15 seconds
                setTimeout(() => {
                    this.closeViolationPopup();
                }, 15000);
            }
            
            // Store tooltip system
            showStoreTooltip(store, event) {
                const tooltip = document.getElementById('tooltip');
                const storeAssets = Array.from(store.assetIds).map(id => this.assets.get(id)).filter(Boolean);
                
                // Build tooltip content
                let content = `<div class="tooltip-header">📦 ${store.label}</div>`;
                content += `<div class="tooltip-content">`;
                content += `<strong>Classification:</strong> ${this.classificationIcons[store.classification]} ${store.classification.toUpperCase()}<br>`;
                content += `<strong>Assets:</strong> ${storeAssets.length}<br>`;
                
                if (storeAssets.length > 0) {
                    content += `<strong>Contains:</strong><br>`;
                    storeAssets.slice(0, 3).forEach(asset => {
                        content += `• ${asset.label}<br>`;
                    });
                    if (storeAssets.length > 3) {
                        content += `• ... and ${storeAssets.length - 3} more`;
                    }
                }
                
                content += `</div>`;
                content += `<div class="tooltip-hint">💡 Right-click to edit store details</div>`;
                
                tooltip.innerHTML = content;
                
                // CORRECTED: Subtract the offset that's causing the displacement
                const storeElement = event.target.closest('g.store') || event.target;
                if (storeElement && storeElement.getBoundingClientRect) {
                    const elementRect = storeElement.getBoundingClientRect();
                    
                    // The element reports x=1037 but visually appears around x=690
                    // So we need to subtract about 347px (1037-690) from the calculated position
                    const offsetCorrection = 347; // Difference between reported and visual position
                    
                    let left = elementRect.right + 15 - offsetCorrection;  // Subtract the displacement
                    let top = elementRect.top - 10;
                    
                    // Keep tooltip within viewport bounds
                    const tooltipWidth = 250;
                    const tooltipHeight = 120;
                    
                    if (left + tooltipWidth > window.innerWidth) {
                        left = elementRect.left - tooltipWidth - 15 - offsetCorrection;
                    }
                    if (top + tooltipHeight > window.innerHeight) {
                        top = elementRect.bottom + 10;
                    }
                    
                    // Ensure minimum distances from edges
                    left = Math.max(10, left);
                    top = Math.max(10, top);
                    
                    tooltip.style.left = left + 'px';
                    tooltip.style.top = top + 'px';
                    tooltip.style.display = 'block';
                    
                    console.log('CORRECTED - Element x:', elementRect.x, 'Corrected left:', left, 'Final position:', left, top);
                } else {
                    // Fallback
                    tooltip.style.left = '500px';
                    tooltip.style.top = '300px';
                    tooltip.style.display = 'block';
                    console.log('FALLBACK positioning used');
                }
            }
                        
            closeViolationPopup() {
                const popup = document.getElementById('violationPopup');
                popup.style.display = 'none';
            }
            
            hideStoreTooltip() {
                const tooltip = document.getElementById('tooltip');
                tooltip.style.display = 'none';
            }
            validateDataIntegrity() {
                const issues = [];
                
                // Check asset-store consistency
                this.assets.forEach(asset => {
                    const store = this.stores.get(asset.storeId);
                    if (!store) {
                        issues.push(`Asset ${asset.id} references non-existent store ${asset.storeId}`);
                    } else if (!store.assetIds.has(asset.id)) {
                        issues.push(`Store ${store.id} doesn't contain asset ${asset.id} but asset references it`);
                        // Auto-fix: add asset to store
                        store.assetIds.add(asset.id);
                    }
                });
                
                // Check store-asset consistency
                this.stores.forEach(store => {
                    store.assetIds.forEach(assetId => {
                        const asset = this.assets.get(assetId);
                        if (!asset) {
                            issues.push(`Store ${store.id} references non-existent asset ${assetId}`);
                            // Auto-fix: remove asset from store
                            store.assetIds.delete(assetId);
                        } else if (asset.storeId !== store.id) {
                            issues.push(`Asset ${assetId} has wrong storeId (${asset.storeId} vs ${store.id})`);
                            // Auto-fix: update asset's storeId
                            asset.storeId = store.id;
                        }
                    });
                });
                
                // Check orphaned links
                this.links.forEach((link, linkId) => {
                    const sourceExists = this.assets.has(link.sourceId);
                    const targetExists = this.assets.has(link.targetId);
                    
                    if (!sourceExists || !targetExists) {
                        issues.push(`Link ${linkId} has orphaned references`);
                        // Auto-fix: remove orphaned link
                        this.links.delete(linkId);
                    }
                });
                
                // Check group references in assets
                this.assets.forEach(asset => {
                    const groupsToRemove = [];
                    asset.accessGroups.forEach(groupId => {
                        if (!this.groups.has(groupId)) {
                            issues.push(`Asset ${asset.id} references non-existent group ${groupId}`);
                            groupsToRemove.push(groupId);
                        }
                    });
                    // Auto-fix: remove non-existent groups
                    groupsToRemove.forEach(groupId => asset.accessGroups.delete(groupId));
                });
                
                if (issues.length > 0) {
                    console.warn('Data integrity issues found and auto-fixed:', issues);
                }
                
                return issues;
            }
            positionAssetsInStore(store) {
                const assetIds = Array.from(store.assetIds);
                const assets = assetIds.map(id => this.assets.get(id)).filter(Boolean);
                
                if (assets.length === 0) return;
                
                if (assets.length === 1) {
                    assets[0].x = store.x;
                    assets[0].y = store.y;
                } else {
                    const assetsPerRow = Math.ceil(Math.sqrt(assets.length));
                    const spacing = 160;
                    const startX = store.x - ((assetsPerRow - 1) * spacing) / 2;
                    const startY = store.y - (Math.ceil(assets.length / assetsPerRow - 1) * spacing) / 2;
                    
                    assets.forEach((asset, index) => {
                        const row = Math.floor(index / assetsPerRow);
                        const col = index % assetsPerRow;
                        asset.x = startX + col * spacing;
                        asset.y = startY + row * spacing;
                    });
                }
            }
            
            getStoreSize(store) {
                const assetCount = store.assetIds.size;
                const baseWidth = 220;
                const baseHeight = 160;
                
                if (assetCount <= 1) {
                    return { width: baseWidth, height: baseHeight };
                }
                
                const assetsPerRow = Math.ceil(Math.sqrt(assetCount));
                const rows = Math.ceil(assetCount / assetsPerRow);
                const spacing = 120;
                const padding = 100;
                
                const width = Math.max(baseWidth, assetsPerRow * spacing + padding);
                const height = Math.max(baseHeight, rows * spacing + padding);
                
                return { width, height };
            }
            
            // Movement operations (FIXED IMPLEMENTATION)
            addDataMovement(type) {
                const template = this.movementTemplates[type];
                if (!template) return;
                
                // Get only original assets (not copies)
                const originalAssets = Array.from(this.assets.values()).filter(a => a.isOriginal);
                
                if (originalAssets.length === 0) {
                    this.showMessage('No original assets to copy', 'error');
                    return;
                }
                
                this.saveState(`Create ${template.label.toLowerCase()}`);
                
                // Create new store for copies
                const newStore = this.createStore(`${template.label} Store`, template.classification);
                
                // Create copies of original assets (without modifying originals)
                originalAssets.forEach(originalAsset => {
                    // Create a completely new asset object
                    const copyAsset = this.createAsset(
                        `${originalAsset.label} (${template.label})`,
                        template.classification,
                        newStore.id,
                        Array.from(originalAsset.accessGroups) // Copy access groups
                    );
                    
                    // Mark as copy and track source
                    copyAsset.isOriginal = false;
                    copyAsset.sourceAssetId = originalAsset.id;
                    
                    // Create visual link
                    this.createLink(originalAsset.id, copyAsset.id, 'copy');
                });
                
                this.updateVisualization();
                this.showMessage(`${template.label} created with ${originalAssets.length} copies. Originals preserved.`, 'success');
            }
            
            // Store management
            addNewDataStore() {
                const classification = document.getElementById('newStoreClassification').value;
                let name = document.getElementById('newStoreName').value.trim();
                
                if (!name) {
                    name = `${classification.charAt(0).toUpperCase() + classification.slice(1)} Store ${this.nextStoreId}`;
                }
                
                // Validate store name
                const existingStore = Array.from(this.stores.values()).find(s => 
                    s.label.toLowerCase() === name.toLowerCase()
                );
                
                if (existingStore) {
                    this.showMessage('A store with this name already exists', 'error');
                    return;
                }
                
                this.saveState('Add data store');
                
                // Create store with initial asset
                const store = this.createStore(name, classification);
                this.createAsset('Data Asset', classification, store.id);
                
                // Clear input
                document.getElementById('newStoreName').value = '';
                
                this.updateVisualization();
                this.showMessage(`Store "${name}" created successfully`, 'success');
            }
            
            // Group management
            addNewGroup() {
                this.saveState('Add access group');
                
                const group = this.createGroup(
                    `Access Group ${this.nextGroupId - 1}`,
                    'individual',
                    'read',
                    'office',
                    'temporary'
                );
                this.renderAccessGroups();
                this.updateVisualization();
            }
            
            addPresetGroup(presetType) {
                this.saveState('Add preset group');
                
                const preset = this.presetGroups[presetType];
                if (!preset) return;
                
                const group = this.createGroup(
                    preset.name,
                    preset.access,
                    preset.permission,
                    preset.location,
                    preset.duration
                );
                this.renderAccessGroups();
                this.updateVisualization();
            }
            
            deleteGroup(groupId) {
                this.saveState('Delete access group');
                
                this.groups.delete(groupId);
                
                // Remove group from all assets
                this.assets.forEach(asset => {
                    asset.accessGroups.delete(groupId);
                });
                
                this.renderAccessGroups();
                this.updateVisualization();
            }
            
            updateGroupProperty(groupId, property, value) {
                const group = this.groups.get(groupId);
                if (!group) return;
                
                if (property === 'name') {
                    if (!value || value.trim().length === 0) {
                        this.showMessage('Group name cannot be empty', 'error');
                        this.renderAccessGroups();
                        return;
                    }
                    
                    const trimmedValue = value.trim();
                    const existingGroup = Array.from(this.groups.values()).find(g => 
                        g.id !== groupId && g.name.toLowerCase() === trimmedValue.toLowerCase()
                    );
                    
                    if (existingGroup) {
                        this.showMessage('A group with this name already exists', 'error');
                        this.renderAccessGroups();
                        return;
                    }
                    
                    group[property] = trimmedValue;
                } else {
                    group[property] = value;
                }
                
                this.updateVisualization();
            }
            
            renderAccessGroups() {
                const container = document.getElementById('accessGroups');
                container.innerHTML = '';
                
                this.groups.forEach(group => {
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'group-item';
                    groupDiv.innerHTML = `
                        <div class="group-header">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div class="group-color" style="background-color: ${group.color};"></div>
                                <input type="text" value="${group.name}" 
                                       onchange="visualizer.updateGroupProperty('${group.id}', 'name', this.value)"
                                       style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); 
                                              border-radius: 3px; padding: 2px 6px; color: #fff; font-size: 0.85em; 
                                              font-weight: bold; width: 140px;">
                            </div>
                            <button class="delete-group" onclick="visualizer.deleteGroup('${group.id}')">×</button>
                        </div>
                        <div class="group-controls">
                            <select onchange="visualizer.updateGroupProperty('${group.id}', 'access', this.value)">
                                <option value="individual" ${group.access === 'individual' ? 'selected' : ''}>Individual</option>
                                <option value="team" ${group.access === 'team' ? 'selected' : ''}>Team</option>
                                <option value="department" ${group.access === 'department' ? 'selected' : ''}>Department</option>
                                <option value="company" ${group.access === 'company' ? 'selected' : ''}>Company</option>
                                <option value="external" ${group.access === 'external' ? 'selected' : ''}>External</option>
                                <option value="world" ${group.access === 'world' ? 'selected' : ''}>World (5.7B)</option>
                            </select>
                            <select onchange="visualizer.updateGroupProperty('${group.id}', 'permission', this.value)">
                                <option value="read" ${group.permission === 'read' ? 'selected' : ''}>Read</option>
                                <option value="edit" ${group.permission === 'edit' ? 'selected' : ''}>Edit</option>
                                <option value="admin" ${group.permission === 'admin' ? 'selected' : ''}>Admin</option>
                            </select>
                            <select onchange="visualizer.updateGroupProperty('${group.id}', 'location', this.value)">
                                <option value="office" ${group.location === 'office' ? 'selected' : ''}>Office</option>
                                <option value="vpn" ${group.location === 'vpn' ? 'selected' : ''}>VPN</option>
                                <option value="anywhere" ${group.location === 'anywhere' ? 'selected' : ''}>Anywhere</option>
                            </select>
                            <select onchange="visualizer.updateGroupProperty('${group.id}', 'duration', this.value)">
                                <option value="temporary" ${group.duration === 'temporary' ? 'selected' : ''}>Temporary</option>
                                <option value="project" ${group.duration === 'project' ? 'selected' : ''}>Project</option>
                                <option value="permanent" ${group.duration === 'permanent' ? 'selected' : ''}>Permanent</option>
                            </select>
                        </div>
                    `;
                    container.appendChild(groupDiv);
                });
            }
            
            // Store controls
            showStoreControls(storeId, event) {
                this.selectedStoreId = storeId;
                const store = this.stores.get(storeId);
                if (!store) return;
                
                const controls = document.getElementById('storeControls');
                document.getElementById('storeControlsTitle').textContent = `${store.label} Configuration`;
                document.getElementById('storeName').value = store.label;
                document.getElementById('storeClassification').value = store.classification;
                
                // Populate asset list
                const assetsList = document.getElementById('storeAssetsList');
                assetsList.innerHTML = '';
                
                if (store.assetIds.size === 0) {
                    assetsList.innerHTML = '<em>No assets in this store</em>';
                } else {
                    Array.from(store.assetIds).forEach(assetId => {
                        const asset = this.assets.get(assetId);
                        if (asset) {
                            const assetDiv = document.createElement('div');
                            assetDiv.innerHTML = `• ${asset.label} (${asset.classification})`;
                            assetsList.appendChild(assetDiv);
                        }
                    });
                }
                
                // CORRECTED POSITIONING: Apply the same fix as the tooltip
                const storeElement = event.target.closest('g.store') || event.target;
                if (storeElement && storeElement.getBoundingClientRect) {
                    const elementRect = storeElement.getBoundingClientRect();
                    
                    // Apply the same offset correction as the tooltip
                    const offsetCorrection = 347; // Same correction used for tooltip
                    
                    let left = elementRect.right + 15 - offsetCorrection;
                    let top = elementRect.top - 10;
                    
                    // Keep controls within viewport bounds
                    const controlsWidth = 300;
                    const controlsHeight = 400;
                    
                    if (left + controlsWidth > window.innerWidth) {
                        left = elementRect.left - controlsWidth - 15 - offsetCorrection;
                    }
                    if (top + controlsHeight > window.innerHeight) {
                        top = elementRect.bottom + 10;
                    }
                    if (top < 20) {
                        top = 20;
                    }
                    
                    // Ensure minimum distance from edges and control panel
                    left = Math.max(400, Math.min(left, window.innerWidth - controlsWidth - 20)); // 400 to clear the control panel
                    top = Math.max(20, Math.min(top, window.innerHeight - controlsHeight - 20));
                    
                    controls.style.left = left + 'px';
                    controls.style.top = top + 'px';
                    controls.style.display = 'block';
                    
                    console.log('STORE CONTROLS CORRECTED - Element x:', elementRect.x, 'Corrected left:', left, 'Final position:', left, top);
                } else {
                    // Fallback positioning
                    controls.style.left = '500px';
                    controls.style.top = '200px';
                    controls.style.display = 'block';
                    console.log('STORE CONTROLS FALLBACK positioning used');
                }
            }

            closeStoreControls() {
                document.getElementById('storeControls').style.display = 'none';
                this.selectedStoreId = null;
            }
            
            updateSelectedStore(property, value) {
                if (!this.selectedStoreId) return;
                
                const store = this.stores.get(this.selectedStoreId);
                if (!store) return;
                
                if (property === 'label') {
                    if (!value || value.trim().length === 0) {
                        this.showMessage('Store name cannot be empty', 'error');
                        return;
                    }
                    
                    const trimmedValue = value.trim();
                    const existingStore = Array.from(this.stores.values()).find(s => 
                        s.id !== this.selectedStoreId && s.label.toLowerCase() === trimmedValue.toLowerCase()
                    );
                    
                    if (existingStore) {
                        this.showMessage('A store with this name already exists', 'error');
                        return;
                    }
                    
                    store[property] = trimmedValue;
                } else {
                    store[property] = value;
                }
                
                this.updateVisualization();
            }
            
            deleteSelectedStore() {
                if (!this.selectedStoreId) return;
                
                const store = this.stores.get(this.selectedStoreId);
                if (!store) return;
                
                if (store.assetIds.size > 0) {
                    this.showMessage('Cannot delete store that contains assets. Move or delete assets first.', 'error');
                    return;
                }
                
                this.saveState('Delete store');
                
                // Remove store
                this.stores.delete(this.selectedStoreId);
                
                this.closeStoreControls();
                this.updateVisualization();
                this.showMessage('Store deleted successfully', 'success');
            }

            showAssetControls(assetId, event) {
                this.selectedAssetId = assetId;
                const asset = this.assets.get(assetId);
                if (!asset) return;
                
                const controls = document.getElementById('assetControls');
                document.getElementById('assetControlsTitle').textContent = `${asset.label} Configuration`;
                document.getElementById('assetName').value = asset.label;
                document.getElementById('assetClassification').value = asset.classification;
                
                // Populate access groups
                const accessGroupsDiv = document.getElementById('assetAccessGroups');
                accessGroupsDiv.innerHTML = '';
                
                this.groups.forEach(group => {
                    const isChecked = asset.accessGroups.has(group.id);
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.className = 'checkbox-item';
                    checkboxDiv.innerHTML = `
                        <input type="checkbox" id="checkbox_${group.id}" ${isChecked ? 'checked' : ''} 
                            onchange="visualizer.toggleAssetAccess('${assetId}', '${group.id}', this.checked)">
                        <label for="checkbox_${group.id}" style="color: ${group.color};">${group.name}</label>
                    `;
                    accessGroupsDiv.appendChild(checkboxDiv);
                });
                
                // CORRECTED POSITIONING: Apply the same fix as tooltip and store controls
                const assetElement = event.target.closest('g.asset') || event.target;
                if (assetElement && assetElement.getBoundingClientRect) {
                    const elementRect = assetElement.getBoundingClientRect();
                    
                    // Apply the same offset correction
                    const offsetCorrection = 347; // Same correction used for tooltip and store controls
                    
                    let left = elementRect.right + 15 - offsetCorrection;
                    let top = elementRect.top - 10;
                    
                    // Keep controls within viewport bounds
                    const controlsWidth = 300;
                    const controlsHeight = 400;
                    
                    if (left + controlsWidth > window.innerWidth) {
                        left = elementRect.left - controlsWidth - 15 - offsetCorrection;
                    }
                    if (top + controlsHeight > window.innerHeight) {
                        top = elementRect.bottom + 10;
                    }
                    if (top < 20) {
                        top = 20;
                    }
                    
                    // Ensure minimum distance from edges and control panel
                    left = Math.max(400, Math.min(left, window.innerWidth - controlsWidth - 20)); // 400 to clear the control panel
                    top = Math.max(20, Math.min(top, window.innerHeight - controlsHeight - 20));
                    
                    controls.style.left = left + 'px';
                    controls.style.top = top + 'px';
                    controls.style.display = 'block';
                    
                    console.log('ASSET CONTROLS CORRECTED - Element x:', elementRect.x, 'Corrected left:', left, 'Final position:', left, top);
                } else {
                    // Fallback positioning
                    controls.style.left = '500px';
                    controls.style.top = '200px';
                    controls.style.display = 'block';
                    console.log('ASSET CONTROLS FALLBACK positioning used');
                }
            }

            closeAssetControls() {
                document.getElementById('assetControls').style.display = 'none';
                this.selectedAssetId = null;
            }
            
            closeAllControls() {
                this.closeAssetControls();
                this.closeStoreControls();
            }
            
            updateSelectedAsset(property, value) {
                if (!this.selectedAssetId) return;
                
                const asset = this.assets.get(this.selectedAssetId);
                if (!asset) return;
                
                if (property === 'label' && (!value || value.trim().length === 0)) {
                    this.showMessage('Asset name cannot be empty', 'error');
                    return;
                }
                
                asset[property] = value.trim ? value.trim() : value;
                this.updateVisualization();
            }
            
            toggleAssetAccess(assetId, groupId, isChecked) {
                const asset = this.assets.get(assetId);
                if (!asset) return;
                
                if (isChecked) {
                    asset.accessGroups.add(groupId);
                } else {
                    asset.accessGroups.delete(groupId);
                }
                
                this.updateVisualization();
            }
            
            separateAsset() {
                if (!this.selectedAssetId) return;
                
                const asset = this.assets.get(this.selectedAssetId);
                if (!asset) return;
                
                const currentStore = this.stores.get(asset.storeId);
                if (!currentStore || currentStore.assetIds.size <= 1) {
                    this.showMessage('Cannot separate the only asset from a store', 'error');
                    return;
                }
                
                this.saveState('Separate asset');
                
                // Remove from current store
                currentStore.assetIds.delete(this.selectedAssetId);
                this.positionAssetsInStore(currentStore);
                
                // Create new store
                const newStore = this.createStore(`${asset.label} Store`, asset.classification, asset.x + 150, asset.y + 100);
                
                // Move asset to new store
                asset.storeId = newStore.id;
                newStore.assetIds.add(this.selectedAssetId);
                this.positionAssetsInStore(newStore);
                
                this.closeAssetControls();
                this.updateVisualization();
            }
            
            deleteSelectedAsset() {
                if (!this.selectedAssetId) return;
                
                const asset = this.assets.get(this.selectedAssetId);
                if (!asset) return;
                
                this.saveState('Delete asset');
                
                const store = this.stores.get(asset.storeId);
                
                // Remove from store
                if (store) {
                    store.assetIds.delete(this.selectedAssetId);
                    
                    // Delete empty store
                    if (store.assetIds.size === 0) {
                        this.stores.delete(store.id);
                    } else {
                        this.positionAssetsInStore(store);
                    }
                }
                
                // Remove asset
                this.assets.delete(this.selectedAssetId);
                
                // Remove associated links
                const linksToDelete = [];
                this.links.forEach((link, id) => {
                    if (link.sourceId === this.selectedAssetId || link.targetId === this.selectedAssetId) {
                        linksToDelete.push(id);
                    }
                });
                linksToDelete.forEach(id => this.links.delete(id));
                
                this.closeAssetControls();
                this.updateVisualization();
                this.showMessage('Asset deleted successfully', 'success');
            }
            
            // Metrics calculation
            calculateMetrics() {
                let totalPeople = 0;
                let classificationViolations = 0;
                let mixedStores = 0;
                let totalComplexity = 0;
                
                // Track people with access by classification level
                const peopleByClassification = {
                    unclassified: new Set(),
                    internal: new Set(),
                    confidential: new Set(),
                    restricted: new Set()
                };
                
                // Calculate people with access per classification
                this.assets.forEach(asset => {
                    asset.accessGroups.forEach(groupId => {
                        const group = this.groups.get(groupId);
                        if (group) {
                            // Add to the appropriate classification bucket
                            if (!peopleByClassification[asset.classification].has(groupId)) {
                                peopleByClassification[asset.classification].add(groupId);
                            }
                        }
                    });
                });
                
                // Calculate totals for each classification
                const classificationTotals = {};
                Object.keys(peopleByClassification).forEach(classification => {
                    let classificationTotal = 0;
                    peopleByClassification[classification].forEach(groupId => {
                        const group = this.groups.get(groupId);
                        if (group) {
                            classificationTotal += this.accessLevels[group.access].people;
                        }
                    });
                    classificationTotals[classification] = classificationTotal;
                    totalPeople += classificationTotal;
                });
                
                // Calculate complexity
                const uniqueGroups = new Set();
                this.assets.forEach(asset => {
                    asset.accessGroups.forEach(groupId => {
                        if (!uniqueGroups.has(groupId)) {
                            uniqueGroups.add(groupId);
                            const group = this.groups.get(groupId);
                            if (group) {
                                totalComplexity += this.accessLevels[group.access].complexity;
                            }
                        }
                    });
                });
                
                // Check violations
                this.stores.forEach(store => {
                    const storeAssets = Array.from(store.assetIds).map(id => this.assets.get(id)).filter(Boolean);
                    const classifications = [...new Set(storeAssets.map(a => a.classification))];
                    
                    // Mixed classification store
                    if (classifications.length > 1) {
                        mixedStores++;
                    }
                    
                    // Classification violations
                    storeAssets.forEach(asset => {
                        if (this.classificationLevels[asset.classification] > this.classificationLevels[store.classification]) {
                            classificationViolations++;
                        }
                        
                        // Access violations
                        asset.accessGroups.forEach(groupId => {
                            const group = this.groups.get(groupId);
                            if (group) {
                                if (group.access === 'external' && 
                                    (asset.classification === 'confidential' || asset.classification === 'restricted')) {
                                    classificationViolations++;
                                }
                                if (group.access === 'world' && 
                                    (asset.classification === 'internal' || asset.classification === 'confidential' || asset.classification === 'restricted')) {
                                    classificationViolations += 10; // World access to non-public data violations count heavily
                                }
                                if (group.access === 'company' && asset.classification === 'restricted') {
                                    classificationViolations++;
                                }
                            }
                        });
                    });
                });
                
                const complexity = totalComplexity > 50 ? 'CRITICAL' : 
                                 totalComplexity > 25 ? 'HIGH' : 
                                 totalComplexity > 10 ? 'MEDIUM' : 'LOW';
                
                return {
                    totalPeople,
                    classificationViolations,
                    mixedStores,
                    dataCopies: this.assets.size,
                    complexity,
                    classificationTotals
                };
            }
            
            // Helper function to format large numbers
            formatNumber(num) {
                if (num >= 1000000000) {
                    return (num / 1000000000).toFixed(1) + 'B';
                } else if (num >= 1000000) {
                    return (num / 1000000).toFixed(1) + 'M';
                } else if (num >= 1000) {
                    return (num / 1000).toFixed(1) + 'K';
                } else {
                    return num.toString();
                }
            }
            
            updateMetrics() {
                const metrics = this.calculateMetrics();
                
                // Update total people count
                document.getElementById('totalPeople').textContent = this.formatNumber(metrics.totalPeople);
                
                // Update classification breakdowns
                document.getElementById('unclassifiedPeople').textContent = this.formatNumber(metrics.classificationTotals.unclassified);
                document.getElementById('internalPeople').textContent = this.formatNumber(metrics.classificationTotals.internal);
                document.getElementById('confidentialPeople').textContent = this.formatNumber(metrics.classificationTotals.confidential);
                document.getElementById('restrictedPeople').textContent = this.formatNumber(metrics.classificationTotals.restricted);
                
                // Apply color coding based on sensitivity and numbers
                this.updateClassificationColors(metrics.classificationTotals);
                
                // Update other metrics
                document.getElementById('classificationViolations').textContent = metrics.classificationViolations;
                document.getElementById('mixedStores').textContent = metrics.mixedStores;
                document.getElementById('dataCopies').textContent = metrics.dataCopies;
                document.getElementById('managementComplexity').textContent = metrics.complexity;
                
                // Generate warnings
                let warningMessage = '';
                if (metrics.classificationViolations > 0) {
                    warningMessage += `<div class="critical-warning">🔥 CRITICAL: ${metrics.classificationViolations} classification violation(s) detected!</div>`;
                }
                if (metrics.mixedStores > 0) {
                    warningMessage += `<div class="warning">⚠️ ${metrics.mixedStores} store(s) contain mixed classification data</div>`;
                }
                if (metrics.complexity === 'CRITICAL') {
                    warningMessage += '<div class="critical-warning">🚨 Management complexity is critical!</div>';
                }
                
                // Check for non-public data with massive exposure (not unclassified)
                const nonPublicExposure = metrics.classificationTotals.internal + 
                                        metrics.classificationTotals.confidential + 
                                        metrics.classificationTotals.restricted;
                
                if (nonPublicExposure > 1000000000) { // Over 1 billion people have access to non-public data
                    warningMessage += '<div class="critical-warning">🌍 CATASTROPHIC BREACH: Over 1 billion people have access to non-public data!</div>';
                }
                
                document.getElementById('warningMessage').innerHTML = warningMessage;
            }
            
            updateClassificationColors(totals) {
                // Color code based on risk level for each classification
                const elements = {
                    unclassified: document.getElementById('unclassifiedPeople'),
                    internal: document.getElementById('internalPeople'),
                    confidential: document.getElementById('confidentialPeople'),
                    restricted: document.getElementById('restrictedPeople')
                };
                
                // Reset colors first
                Object.values(elements).forEach(el => {
                    if (el) el.style.color = '#fff';
                });
                
                // Apply risk-based coloring - ONLY for non-public data
                
                // Restricted data - highest risk, should have very limited access
                if (totals.restricted > 100) {
                    elements.restricted.style.color = '#ff4757'; // Red for high restricted access
                } else if (totals.restricted > 10) {
                    elements.restricted.style.color = '#ffa502'; // Orange for moderate restricted access
                }
                
                // Confidential data - should be limited to business need
                if (totals.confidential > 10000) {
                    elements.confidential.style.color = '#ff4757'; // Red for very high confidential access
                } else if (totals.confidential > 1000) {
                    elements.confidential.style.color = '#ffa502'; // Orange for high confidential access
                }
                
                // Internal data - should stay within organization
                if (totals.internal > 1000000000) { // World access to internal data = major breach
                    elements.internal.style.color = '#ff4757'; // Red for global exposure of internal data
                } else if (totals.internal > 100000) {
                    elements.internal.style.color = '#ffa502'; // Orange for very high internal access
                }
                
                // Unclassified data - NO RISK COLORING (can be public)
                // Unclassified data can safely be exposed to billions without security risk
            }
            
            // Visualization
            updateVisualization() {
                // Validate data integrity before updating
                this.validateDataIntegrity();
                
                this.updateMetrics();
                this.drawVisualization();
            }
            
            drawVisualization() {
                this.g.selectAll('*').remove();
                
                // Position assets in stores
                this.stores.forEach(store => {
                    this.positionAssetsInStore(store);
                });
                
                // Draw stores
                const storeData = Array.from(this.stores.values());
                const storeSelection = this.g.selectAll('.store')
                    .data(storeData, d => d.id)
                    .enter().append('g')
                    .attr('class', 'store');
                
                // Store rectangles
                storeSelection.append('rect')
                    .attr('x', d => {
                        const { width } = this.getStoreSize(d);
                        return d.x - width / 2;
                    })
                    .attr('y', d => {
                        const { height } = this.getStoreSize(d);
                        return d.y - height / 2;
                    })
                    .attr('width', d => this.getStoreSize(d).width)
                    .attr('height', d => this.getStoreSize(d).height)
                    .attr('fill', d => {
                        // Check for violations
                        const storeAssets = Array.from(d.assetIds).map(id => this.assets.get(id)).filter(Boolean);
                        const hasViolation = storeAssets.some(asset => 
                            this.classificationLevels[asset.classification] > this.classificationLevels[d.classification]
                        );
                        return hasViolation ? '#ff4757' : this.classificationColors[d.classification];
                    })
                    .attr('stroke', '#ffffff')
                    .attr('stroke-width', 2)
                    .attr('rx', 8)
                    .style('filter', 'drop-shadow(0 3px 6px rgba(0,0,0,0.3))')
                    .style('cursor', 'move')
                    .on('contextmenu', (event, d) => {
                        event.preventDefault();
                        this.showStoreControls(d.id, event);
                    })
                    .on('mouseover', (event, d) => {
                        this.showStoreTooltip(d, event);
                    })
                    .on('mouseout', () => {
                        this.hideStoreTooltip();
                    })
                    .call(this.createDragBehavior('store'));
                
                // Store labels
                storeSelection.append('text')
                    .attr('x', d => d.x)
                    .attr('y', d => {
                        const { height } = this.getStoreSize(d);
                        return d.y - height / 2 - 10;
                    })
                    .attr('class', 'node-label')
                    .style('font-size', '16px')
                    .text(d => d.label);
                
                // Store icons
                storeSelection.append('text')
                    .attr('x', d => d.x)
                    .attr('y', d => {
                        const { height } = this.getStoreSize(d);
                        return d.y + height / 2 + 20;
                    })
                    .style('font-size', '24px')
                    .style('text-anchor', 'middle')
                    .text(d => this.classificationIcons[d.classification]);
                
                // Draw links
                const linkData = Array.from(this.links.values());
                this.g.selectAll('.link')
                    .data(linkData, d => d.id)
                    .enter().append('line')
                    .attr('class', d => `link ${d.type === 'copy' ? 'copy-link' : ''}`)
                    .attr('x1', d => {
                        const source = this.assets.get(d.sourceId);
                        return source ? source.x : 0;
                    })
                    .attr('y1', d => {
                        const source = this.assets.get(d.sourceId);
                        return source ? source.y : 0;
                    })
                    .attr('x2', d => {
                        const target = this.assets.get(d.targetId);
                        return target ? target.x : 0;
                    })
                    .attr('y2', d => {
                        const target = this.assets.get(d.targetId);
                        return target ? target.y : 0;
                    });
                
                // Draw access group halos
                this.groups.forEach(group => {
                    const groupAssets = Array.from(this.assets.values()).filter(a => a.accessGroups.has(group.id));
                    if (groupAssets.length > 0) {
                        this.g.selectAll(`.halo-${group.id}`)
                            .data(groupAssets)
                            .enter().append('circle')
                            .attr('class', `halo-${group.id}`)
                            .attr('cx', d => d.x)
                            .attr('cy', d => d.y)
                            .attr('r', 40)
                            .attr('fill', group.color)
                            .attr('opacity', 0.1)
                            .attr('stroke', group.color)
                            .attr('stroke-width', 1)
                            .attr('stroke-opacity', 0.3);
                    }
                });
                
                // Draw assets
                const assetData = Array.from(this.assets.values());
                const assetSelection = this.g.selectAll('.asset')
                    .data(assetData, d => d.id)
                    .enter().append('g')
                    .attr('class', 'asset');
                
                // Asset circles
                assetSelection.append('circle')
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('r', 32)
                    .attr('fill', d => {
                        const store = this.stores.get(d.storeId);
                        const hasViolation = store && 
                            this.classificationLevels[d.classification] > this.classificationLevels[store.classification];
                        return hasViolation ? '#ff4757' : this.classificationColors[d.classification];
                    })
                    .attr('stroke', '#ffffff')
                    .attr('stroke-width', 3)
                    .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.3))')
                    .style('cursor', 'move')
                    .on('click', (event, d) => {
                        event.stopPropagation();
                        this.showAssetControls(d.id, event);
                    })
                    .call(this.createDragBehavior('asset'));
                
                // Asset labels
                assetSelection.append('text')
                    .attr('x', d => d.x)
                    .attr('y', d => d.y + 55)
                    .attr('class', 'node-label')
                    .style('font-size', '14px')
                    .text(d => d.label);
                
                // Asset icons
                assetSelection.append('text')
                    .attr('x', d => d.x)
                    .attr('y', d => d.y + 3)
                    .style('font-size', '12px')
                    .style('text-anchor', 'middle')
                    .text(d => this.classificationIcons[d.classification]);
                
                // Add violation indicators
                this.addViolationIndicators();
            }
            
            addViolationIndicators() {
                // Remove existing violation indicators first
                this.g.selectAll('.violation-indicator').remove();
                
                const violations = this.calculateViolationDetails();
                
                // Create new violation indicators with proper positioning
                this.g.selectAll('.violation-indicator')
                    .data(violations, d => d.id)
                    .enter().append('text')
                    .attr('class', 'violation-indicator')
                    .attr('x', d => d.x)
                    .attr('y', d => d.y)
                    .style('font-size', '16px')
                    .style('cursor', 'pointer')
                    .style('pointer-events', 'all')
                    .style('text-shadow', '1px 1px 2px rgba(0,0,0,0.8)')
                    .text(d => d.severity === 'CRITICAL' ? '🔥' : '⚠️')
                    .on('click', (event, d) => {
                        event.stopPropagation();
                        this.showViolationPopup(d, event);
                    });
            }
            
            calculateViolationDetails() {
                const violations = [];
                
                this.assets.forEach(asset => {
                    const store = this.stores.get(asset.storeId);
                    if (!store) return;
                    
                    // Classification violations - position relative to current asset position
                    if (this.classificationLevels[asset.classification] > this.classificationLevels[store.classification]) {
                        violations.push({
                            id: `classification_${asset.id}`,
                            type: 'classification',
                            severity: 'CRITICAL',
                            x: asset.x + 25, // Always relative to current asset position
                            y: asset.y - 20,
                            description: `Classification Mismatch: "${asset.label}" (${asset.classification.toUpperCase()}) is stored in "${store.label}" (${store.classification.toUpperCase()}). This violates data classification policies.`,
                            recommendation: `Move "${asset.label}" to a ${asset.classification.toUpperCase()} classified store, or downgrade the asset classification if appropriate.`
                        });
                    }
                    
                    // Access violations - position relative to current asset position
                    asset.accessGroups.forEach(groupId => {
                        const group = this.groups.get(groupId);
                        if (!group) return;
                        
                        let violationFound = false;
                        let violationDescription = '';
                        let recommendation = '';
                        
                        if (group.access === 'external' && (asset.classification === 'confidential' || asset.classification === 'restricted')) {
                            violationFound = true;
                            violationDescription = `External Access Violation: "${group.name}" (external users) has access to "${asset.label}" (${asset.classification.toUpperCase()}). External users should not access confidential or restricted data.`;
                            recommendation = `Remove external access to this ${asset.classification} asset, or consider downgrading classification if external access is necessary.`;
                        } else if (group.access === 'world' && (asset.classification === 'internal' || asset.classification === 'confidential' || asset.classification === 'restricted')) {
                            violationFound = true;
                            violationDescription = `🚨 MASSIVE EXPOSURE: "${group.name}" (5.7 billion people globally) has access to "${asset.label}" (${asset.classification.toUpperCase()}). This represents a catastrophic data breach scenario.`;
                            recommendation = `IMMEDIATE ACTION REQUIRED: Remove world access from this ${asset.classification} asset. Only unclassified public data should have world-wide access.`;
                        } else if (group.access === 'company' && asset.classification === 'restricted') {
                            violationFound = true;
                            violationDescription = `Over-privileged Access: "${group.name}" (company-wide) has access to "${asset.label}" (RESTRICTED). Restricted data should follow need-to-know principles.`;
                            recommendation = `Restrict access to specific departments or teams that require this data for their job functions.`;
                        } else if (group.location === 'anywhere' && asset.classification === 'restricted') {
                            violationFound = true;
                            violationDescription = `Location Risk: "${group.name}" can access "${asset.label}" (RESTRICTED) from anywhere. Restricted data should have location controls.`;
                            recommendation = `Limit access to office or VPN-only locations for restricted data.`;
                        }
                        
                        if (violationFound) {
                            violations.push({
                                id: `access_${asset.id}_${groupId}`,
                                type: 'access',
                                severity: group.access === 'world' ? 'CRITICAL' : 'HIGH',
                                x: asset.x - 45, // Always relative to current asset position
                                y: asset.y - 20,
                                description: violationDescription,
                                recommendation: recommendation
                            });
                        }
                    });
                });
                
                // Mixed classification store violations - position relative to current store position
                this.stores.forEach(store => {
                    const storeAssets = Array.from(store.assetIds).map(id => this.assets.get(id)).filter(Boolean);
                    const classifications = [...new Set(storeAssets.map(a => a.classification))];
                    
                    if (classifications.length > 1) {
                        const assetList = storeAssets.map(a => `"${a.label}" (${a.classification.toUpperCase()})`).join(', ');
                        const storeSize = this.getStoreSize(store);
                        violations.push({
                            id: `mixed_${store.id}`,
                            type: 'mixed-store',
                            severity: 'CRITICAL',
                            x: store.x + (storeSize.width / 2) - 15, // Position relative to current store position
                            y: store.y - (storeSize.height / 2) - 5,
                            description: `Mixed Classification Storage: "${store.label}" contains assets with different classification levels: ${assetList}. This creates data spillage risks.`,
                            recommendation: `Separate assets into stores matching their classification levels. Create dedicated stores for each classification level to maintain proper data compartmentalization.`
                        });
                    }
                });
                
                return violations;
            }
            
            createDragBehavior(type) {
                return d3.drag()
                    .on('start', (event, d) => this.dragStarted(event, d))
                    .on('drag', (event, d) => type === 'store' ? this.draggedStore(event, d) : this.draggedAsset(event, d))
                    .on('end', (event, d) => this.dragEnded(event, d));
            }
            
            dragStarted(event, d) {
                d.isDragging = true;
                d.dragOffsetX = event.x - d.x;
                d.dragOffsetY = event.y - d.y;
                
                // Check for Ctrl key for asset separation
                if (d.storeId && this.isCtrlPressed) {
                    d.separateOnDrag = true;
                    this.showMessage('Ctrl+Drag: Will separate asset to new store', 'success');
                }
            }
            
            draggedStore(event, d) {
                const newX = event.x - d.dragOffsetX;
                const newY = event.y - d.dragOffsetY;
                
                const { width, height } = this.getStoreSize(d);
                const margin = Math.max(50, width / 2, height / 2);
                
                d.x = Math.max(width/2 + margin, Math.min(this.width - width/2 - margin, newX));
                d.y = Math.max(height/2 + margin, Math.min(this.height - height/2 - margin, newY));
                
                this.positionAssetsInStore(d);
                this.updatePositions();
            }
            
            draggedAsset(event, d) {
                const newX = event.x - d.dragOffsetX;
                const newY = event.y - d.dragOffsetY;
                
                const margin = 30;
                d.x = Math.max(margin, Math.min(this.width - margin, newX));
                d.y = Math.max(margin, Math.min(this.height - margin, newY));
                
                // Highlight potential drop targets
                this.g.selectAll('rect').attr('stroke', '#ffffff').attr('stroke-width', 2);
                
                const targetStore = Array.from(this.stores.values()).find(store => {
                    if (store.id === d.storeId) return false;
                    const { width, height } = this.getStoreSize(store);
                    const dx = Math.abs(store.x - d.x);
                    const dy = Math.abs(store.y - d.y);
                    return dx < width / 2 && dy < height / 2;
                });
                
                if (targetStore) {
                    this.g.selectAll('rect')
                        .filter(storeData => storeData.id === targetStore.id)
                        .attr('stroke', '#00d4aa')
                        .attr('stroke-width', 4);
                }
                
                this.updatePositions();
            }
            
            dragEnded(event, d) {
                if (!d.isDragging) return;
                d.isDragging = false;
                
                this.g.selectAll('rect').attr('stroke', '#ffffff').attr('stroke-width', 2);
                
                if (d.storeId) { // This is an asset
                    if (d.separateOnDrag) {
                        // Ctrl+Drag: Separate asset to new store
                        const currentStore = this.stores.get(d.storeId);
                        if (currentStore && currentStore.assetIds.size > 1) {
                            // Remove from current store
                            currentStore.assetIds.delete(d.id);
                            this.positionAssetsInStore(currentStore);
                            
                            // Create new store at drag location
                            const newStore = this.createStore(`${d.label} Store`, d.classification, d.x, d.y);
                            
                            // Move asset to new store
                            d.storeId = newStore.id;
                            newStore.assetIds.add(d.id);
                            this.positionAssetsInStore(newStore);
                            
                            this.updateVisualization();
                            this.showMessage(`Separated "${d.label}" to new store`, 'success');
                        } else {
                            this.showMessage('Cannot separate the only asset from a store', 'error');
                            // Snap back to original position
                            const originalStore = this.stores.get(d.storeId);
                            if (originalStore) {
                                this.positionAssetsInStore(originalStore);
                                this.updatePositions();
                            }
                        }
                        delete d.separateOnDrag;
                    } else {
                        // Normal drag: Try to move to another store
                        const targetStore = Array.from(this.stores.values()).find(store => {
                            if (store.id === d.storeId) return false;
                            const { width, height } = this.getStoreSize(store);
                            const dx = Math.abs(store.x - d.x);
                            const dy = Math.abs(store.y - d.y);
                            return dx < width / 2 && dy < height / 2;
                        });
                        
                        if (targetStore) {
                            // Move asset to new store
                            const oldStore = this.stores.get(d.storeId);
                            if (oldStore) {
                                oldStore.assetIds.delete(d.id);
                                if (oldStore.assetIds.size === 0) {
                                    this.stores.delete(oldStore.id);
                                } else {
                                    this.positionAssetsInStore(oldStore);
                                }
                            }
                            
                            targetStore.assetIds.add(d.id);
                            d.storeId = targetStore.id;
                            this.positionAssetsInStore(targetStore);
                            
                            this.updateVisualization();
                            this.showMessage(`Moved "${d.label}" to "${targetStore.label}"`, 'success');
                        } else {
                            // Snap back to original store
                            const originalStore = this.stores.get(d.storeId);
                            if (originalStore) {
                                this.positionAssetsInStore(originalStore);
                            }
                            this.updatePositions();
                        }
                    }
                } else {
                    // Store was dragged
                    this.positionAssetsInStore(d);
                    this.updatePositions();
                }
                
                delete d.dragOffsetX;
                delete d.dragOffsetY;
            }
            
            updatePositions() {
                // Update store positions
                this.g.selectAll('.store')
                    .select('rect')
                    .attr('x', d => {
                        const { width } = this.getStoreSize(d);
                        return d.x - width / 2;
                    })
                    .attr('y', d => {
                        const { height } = this.getStoreSize(d);
                        return d.y - height / 2;
                    })
                    .attr('width', d => this.getStoreSize(d).width)
                    .attr('height', d => this.getStoreSize(d).height);
                
                // Update store labels
                this.g.selectAll('.store')
                    .select('text:first-of-type')
                    .attr('x', d => d.x)
                    .attr('y', d => {
                        const { height } = this.getStoreSize(d);
                        return d.y - height / 2 - 10;
                    });
                
                // Update store icons
                this.g.selectAll('.store')
                    .select('text:last-of-type')
                    .attr('x', d => d.x)
                    .attr('y', d => {
                        const { height } = this.getStoreSize(d);
                        return d.y + height / 2 + 20;
                    });
                
                // Update asset positions
                this.g.selectAll('.asset')
                    .select('circle')
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                this.g.selectAll('.asset')
                    .select('text.node-label')
                    .attr('x', d => d.x)
                    .attr('y', d => d.y + 55);
                
                this.g.selectAll('.asset')
                    .select('text:not(.node-label)')
                    .attr('x', d => d.x)
                    .attr('y', d => d.y + 3);
                
                // Update access group halos
                this.groups.forEach(group => {
                    this.g.selectAll(`.halo-${group.id}`)
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y);
                });
                
                // Update links
                this.g.selectAll('.link')
                    .attr('x1', d => {
                        const source = this.assets.get(d.sourceId);
                        return source ? source.x : 0;
                    })
                    .attr('y1', d => {
                        const source = this.assets.get(d.sourceId);
                        return source ? source.y : 0;
                    })
                    .attr('x2', d => {
                        const target = this.assets.get(d.targetId);
                        return target ? target.x : 0;
                    })
                    .attr('y2', d => {
                        const target = this.assets.get(d.targetId);
                        return target ? target.y : 0;
                    });
                
                // Update violation indicators - CRITICAL FIX
                this.updateViolationIndicatorPositions();
            }
            
            updateViolationIndicatorPositions() {
                // Recalculate violation positions based on current asset/store positions
                const violations = this.calculateViolationDetails();
                
                // Update existing violation indicators with new positions
                this.g.selectAll('.violation-indicator')
                    .data(violations, d => d.id)
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            }
            
            // Demo scenario
            loadDemo() {
                this.saveState('Load demo scenario');
                
                // Clear existing data
                this.stores.clear();
                this.assets.clear();
                this.groups.clear();
                this.links.clear();
                this.nextStoreId = 1;
                this.nextAssetId = 1;
                this.nextGroupId = 1;
                this.nextLinkId = 1;
                
                // Create access groups
                const executivesGroup = this.createGroup('Executive Team', 'team', 'admin', 'anywhere', 'permanent');
                const allStaffGroup = this.createGroup('All Staff', 'company', 'read', 'office', 'permanent');
                const hrGroup = this.createGroup('HR Department', 'department', 'edit', 'office', 'permanent');
                const contractorsGroup = this.createGroup('External Contractors', 'external', 'read', 'anywhere', 'temporary');
                const devsGroup = this.createGroup('Development Team', 'team', 'admin', 'vpn', 'project');
                
                // Create stores with violations
                const mixedStore = this.createStore('Legacy Mixed Database', 'internal', 200, 200);
                const devStore = this.createStore('Development Environment', 'unclassified', 500, 200);
                const backupStore = this.createStore('Cloud Backup', 'confidential', 350, 400);
                const secureStore = this.createStore('Secure HR Vault', 'restricted', 650, 350);
                
                // Create assets with violations
                const payrollAsset = this.createAsset('Employee Payroll Data', 'restricted', mixedStore.id, [hrGroup.id, allStaffGroup.id]);
                const publicAsset = this.createAsset('Company Newsletter', 'unclassified', mixedStore.id, [allStaffGroup.id]);
                const customerDevAsset = this.createAsset('Customer Data (Dev Copy)', 'confidential', devStore.id, [devsGroup.id, contractorsGroup.id]);
                const backupAsset = this.createAsset('Full System Backup', 'restricted', backupStore.id, [executivesGroup.id, allStaffGroup.id, contractorsGroup.id]);
                const secureHRAsset = this.createAsset('Secure Employee Records', 'restricted', secureStore.id, [hrGroup.id]);
                
                // Create problematic links
                this.createLink(payrollAsset.id, customerDevAsset.id, 'copy');
                this.createLink(payrollAsset.id, backupAsset.id, 'copy');
                
                this.renderAccessGroups();
                this.updateVisualization();
                this.showMessage('Demo scenario loaded with multiple PoLP violations', 'success');
            }
            
            // Utility functions
            showMessage(message, type = 'error') {
                const container = type === 'success' ? 
                    document.getElementById('storeSuccessMessage') : 
                    document.getElementById('storeErrorMessage');
                
                // Clear both containers
                document.getElementById('storeErrorMessage').style.display = 'none';
                document.getElementById('storeSuccessMessage').style.display = 'none';
                
                container.textContent = message;
                container.style.display = 'block';
                
                setTimeout(() => {
                    container.style.display = 'none';
                }, 3000);
            }
            
            zoomIn() {
                this.svg.transition().duration(300).call(this.zoom.scaleBy, 1.5);
            }
            
            zoomOut() {
                this.svg.transition().duration(300).call(this.zoom.scaleBy, 1 / 1.5);
            }
            
            resetZoom() {
                this.svg.transition().duration(500).call(this.zoom.transform, d3.zoomIdentity);
            }
            
            resetVisualization() {
                this.saveState('Reset visualization');
                
                this.stores.clear();
                this.assets.clear();
                this.groups.clear();
                this.links.clear();
                this.nextStoreId = 1;
                this.nextAssetId = 1;
                this.nextGroupId = 1;
                this.nextLinkId = 1;
                
                this.closeAllControls();
                this.initialize();
                this.showMessage('Visualization reset to initial state', 'success');
            }
            
            exportConfiguration() {
                const config = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    stores: Array.from(this.stores.values()).map(store => ({
                        ...store,
                        assetIds: Array.from(store.assetIds) // Convert Set to Array properly
                    })),
                    assets: Array.from(this.assets.values()).map(asset => ({
                        ...asset,
                        accessGroups: Array.from(asset.accessGroups)
                    })),
                    groups: Array.from(this.groups.values()),
                    links: Array.from(this.links.values()),
                    counters: {
                        nextStoreId: this.nextStoreId,
                        nextAssetId: this.nextAssetId,
                        nextGroupId: this.nextGroupId,
                        nextLinkId: this.nextLinkId
                    }
                };
                
                const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `polp-configuration-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.showMessage('Configuration exported successfully', 'success');
            }
            
            importConfiguration(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const config = JSON.parse(e.target.result);
                        
                        // Validate configuration structure
                        if (!config.stores || !config.assets || !config.groups) {
                            throw new Error('Invalid configuration file format - missing required sections');
                        }
                        
                        console.log('Importing configuration:', config);
                        
                        this.saveState('Import configuration');
                        
                        // Clear existing data
                        this.stores.clear();
                        this.assets.clear();
                        this.groups.clear();
                        this.links.clear();
                        
                        // Import stores with proper assetIds handling
                        if (config.stores) {
                            config.stores.forEach(store => {
                                // Handle both old format (Set serialized as {}) and new format (Array)
                                let assetIds = store.assetIds;
                                if (typeof assetIds === 'object' && !Array.isArray(assetIds)) {
                                    // Old format - assetIds was serialized as an object
                                    assetIds = Object.keys(assetIds).length > 0 ? Object.keys(assetIds) : [];
                                } else if (!Array.isArray(assetIds)) {
                                    // Fallback - ensure it's an array
                                    assetIds = [];
                                }
                                
                                const restoredStore = { 
                                    ...store, 
                                    assetIds: new Set(assetIds)
                                };
                                
                                // Clean up drag state properties
                                delete restoredStore.isDragging;
                                
                                this.stores.set(store.id, restoredStore);
                                console.log(`Imported store ${store.id} with ${assetIds.length} assets`);
                            });
                        }
                        
                        // Import assets
                        if (config.assets) {
                            config.assets.forEach(asset => {
                                const restoredAsset = { 
                                    ...asset, 
                                    accessGroups: new Set(asset.accessGroups || [])
                                };
                                
                                // Clean up drag state properties
                                delete restoredAsset.isDragging;
                                
                                this.assets.set(asset.id, restoredAsset);
                                console.log(`Imported asset ${asset.id} in store ${asset.storeId}`);
                            });
                        }
                        
                        // Import groups
                        if (config.groups) {
                            config.groups.forEach(group => {
                                this.groups.set(group.id, group);
                                console.log(`Imported group ${group.id}: ${group.name}`);
                            });
                        }
                        
                        // Import links
                        if (config.links) {
                            config.links.forEach(link => {
                                this.links.set(link.id, link);
                                console.log(`Imported link ${link.id}`);
                            });
                        }
                        
                        // Import counters
                        if (config.counters) {
                            this.nextStoreId = config.counters.nextStoreId || 1;
                            this.nextAssetId = config.counters.nextAssetId || 1;
                            this.nextGroupId = config.counters.nextGroupId || 1;
                            this.nextLinkId = config.counters.nextLinkId || 1;
                        }
                        
                        // Validate data integrity after import
                        this.validateDataIntegrity();
                        
                        // Update UI
                        this.renderAccessGroups();
                        this.updateVisualization();
                        
                        console.log('Import completed successfully');
                        console.log('Final state:', {
                            stores: this.stores.size,
                            assets: this.assets.size,
                            groups: this.groups.size,
                            links: this.links.size
                        });
                        
                        this.showMessage('Configuration imported successfully', 'success');
                        
                    } catch (error) {
                        console.error('Import error:', error);
                        this.showMessage(`Import failed: ${error.message}`, 'error');
                    }
                };
                reader.readAsText(file);
                
                // Reset file input
                event.target.value = '';
            }
            
            // Initialize with basic setup
            initialize() {
                const initialStore = this.createStore('Primary Data Store', 'confidential', this.width / 2, this.height / 2);
                this.createAsset('Sensitive Customer Data', 'confidential', initialStore.id);
                
                // Save initial state
                this.saveState('Initial state');
                
                this.updateVisualization();
            }
        }
        
        // Global instance
        let visualizer;
        
        // Global functions for onclick handlers
        function addNewDataStore() { visualizer.addNewDataStore(); }
        function addNewGroup() { visualizer.addNewGroup(); }
        function addPresetGroup(type) { visualizer.addPresetGroup(type); }
        function addDataMovement(type) { visualizer.addDataMovement(type); }
        function loadDemo() { visualizer.loadDemo(); }
        function resetVisualization() { visualizer.resetVisualization(); }
        function exportConfiguration() { visualizer.exportConfiguration(); }
        function importConfiguration(event) { visualizer.importConfiguration(event); }
        function separateAsset() { visualizer.separateAsset(); }
        function deleteSelectedAsset() { visualizer.deleteSelectedAsset(); }
        function updateSelectedAsset(property, value) { visualizer.updateSelectedAsset(property, value); }
        function closeAssetControls() { visualizer.closeAssetControls(); }
        function closeStoreControls() { visualizer.closeStoreControls(); }
        function updateSelectedStore(property, value) { visualizer.updateSelectedStore(property, value); }
        function deleteSelectedStore() { visualizer.deleteSelectedStore(); }
        function toggleAssetAccess(assetId, groupId, isChecked) { visualizer.toggleAssetAccess(assetId, groupId, isChecked); }
        function zoomIn() { visualizer.zoomIn(); }
        function zoomOut() { visualizer.zoomOut(); }
        function resetZoom() { visualizer.resetZoom(); }
        function undo() { visualizer.undo(); }
        function redo() { visualizer.redo(); }
        function hideShortcuts() { visualizer.hideShortcutsHelp(); }
        function closeViolationPopup() { visualizer.closeViolationPopup(); }
        
        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            visualizer = new PolpVisualizer();
            
            // Global click handler
            document.addEventListener('click', (event) => {
                if (!event.target.closest('.asset-controls') && !event.target.closest('.asset')) {
                    visualizer.closeAllControls();
                }
            });
            
            // Keyboard event handlers for Ctrl key detection
            document.addEventListener('keydown', (event) => {
                if (event.ctrlKey || event.metaKey) {
                    visualizer.isCtrlPressed = true;
                }
                
                // Handle keyboard shortcuts
                visualizer.handleKeyboardShortcut(event);
            });
            
            document.addEventListener('keyup', (event) => {
                if (!event.ctrlKey && !event.metaKey) {
                    visualizer.isCtrlPressed = false;
                }
            });
            
            // Prevent context menu on stores for right-click functionality
            document.addEventListener('contextmenu', (event) => {
                if (event.target.closest('.store')) {
                    event.preventDefault();
                }
            });
            
            // Window resize handler
            window.addEventListener('resize', () => {
                visualizer.width = window.innerWidth - 380;
                visualizer.height = window.innerHeight;
                visualizer.svg.attr('width', visualizer.width).attr('height', visualizer.height);
                visualizer.closeAllControls();
            });
            
            // Focus loss detection for Ctrl key
            window.addEventListener('blur', () => {
                visualizer.isCtrlPressed = false;
            });
            
            // Show initial help message
            setTimeout(() => {
                visualizer.showMessage('Press H for keyboard shortcuts, right-click stores to edit', 'success');
            }, 2000);
        });
    </script>
</body>
</html>