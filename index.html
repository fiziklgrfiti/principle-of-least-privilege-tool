<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PoLP Attack Surface Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 380px 1fr;
            height: 100vh;
        }

        .control-panel {
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            padding: 20px;
            border-right: 2px solid #333;
            overflow-y: auto;
        }

        .visualization {
            position: relative;
            background: radial-gradient(circle at center, #0f0f23 0%, #000000 100%);
        }

        .zoom-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.3s ease;
        }

        .zoom-btn:hover {
            background: rgba(0, 212, 170, 0.8);
            transform: scale(1.1);
        }

        h1 {
            color: #00d4aa;
            margin-bottom: 20px;
            font-size: 1.4em;
            text-align: center;
        }

        .section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
        }

        .section h3 {
            color: #00d4aa;
            margin-bottom: 12px;
            font-size: 1em;
        }

        .metrics {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 2px solid #e74c3c;
        }

        .metric-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.9em;
            color: #ecf0f1;
        }

        .metric-value {
            font-weight: bold;
            color: #fff;
        }

        .form-group {
            margin-bottom: 12px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
            font-size: 0.85em;
        }

        select, input[type="text"] {
            width: 100%;
            padding: 6px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: #fff;
            font-size: 0.85em;
        }

        select option {
            background: #1a1a2e;
            color: #fff;
        }

        .access-groups {
            max-height: 300px;
            overflow-y: auto;
        }

        .group-item {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            position: relative;
        }

        .group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .group-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #fff;
        }

        .group-name {
            font-weight: bold;
            font-size: 0.9em;
        }

        .delete-group {
            background: #ff4757;
            border: none;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
        }

        .group-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 0.8em;
        }

        .group-controls select {
            padding: 4px;
            font-size: 0.8em;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }

        .preset-btn {
            padding: 6px 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 0.75em;
            transition: all 0.3s ease;
        }

        .preset-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
        }

        .movement-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        button {
            padding: 8px 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .warning {
            background: linear-gradient(135deg, #ff9500 0%, #ff5722 100%);
            padding: 8px;
            border-radius: 5px;
            margin-top: 8px;
            animation: pulse 2s infinite;
            font-size: 0.85em;
        }

        .critical-warning {
            background: linear-gradient(135deg, #ff4757 0%, #c44569 100%);
            padding: 8px;
            border-radius: 5px;
            margin-top: 8px;
            animation: pulse 1s infinite;
            font-size: 0.85em;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .reset-btn {
            background: linear-gradient(135deg, #ff4757 0%, #c44569 100%);
            width: 100%;
            margin-top: 15px;
            padding: 10px;
        }

        .add-group-btn {
            background: linear-gradient(135deg, #00d4aa 0%, #01a3a4 100%);
            width: 100%;
            margin-bottom: 10px;
            padding: 8px;
        }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.85em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 3px;
        }

        .node-label {
            fill: white;
            font-size: 11px;
            text-anchor: middle;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .asset {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .asset:hover {
            stroke-width: 4px;
            filter: brightness(1.2);
        }

        .store {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .store:hover {
            stroke-width: 4px;
            filter: brightness(1.2);
        }

        .asset-controls {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            min-width: 250px;
            z-index: 1000;
            display: none;
        }

        .asset-controls h4 {
            color: #00d4aa;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .checkbox-group {
            max-height: 120px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 5px;
            margin-bottom: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.8em;
        }

        .checkbox-item input[type="checkbox"] {
            margin-right: 8px;
            width: auto;
        }

        .close-controls {
            position: absolute;
            top: 5px;
            right: 8px;
            background: none;
            border: none;
            color: #fff;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            width: 20px;
            height: 20px;
        }

        .violation-indicator {
            position: absolute;
            pointer-events: none;
            z-index: 999;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }

        .error-message {
            background: #ff4757;
            color: white;
            padding: 8px;
            border-radius: 4px;
            margin: 5px 0;
            font-size: 0.85em;
            display: none;
        }

        .success-message {
            background: #2ecc71;
            color: white;
            padding: 8px;
            border-radius: 4px;
            margin: 5px 0;
            font-size: 0.85em;
            display: none;
        }

        .copy-link {
            stroke: #74b9ff;
            stroke-width: 2;
            stroke-dasharray: 5,5;
            stroke-opacity: 0.6;
            animation: dashFlow 2s linear infinite;
        }

        @keyframes dashFlow {
            to {
                stroke-dashoffset: -10;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="control-panel">
            <h1>🛡️ PoLP Visualizer</h1>
            
            <div class="section metrics">
                <h3>📊 PoLP Metrics</h3>
                <div class="metric-item">
                    <span>Total People with Access:</span>
                    <span id="totalPeople" class="metric-value">0</span>
                </div>
                <div class="metric-item">
                    <span>Data Classification Violations:</span>
                    <span id="classificationViolations" class="metric-value">0</span>
                </div>
                <div class="metric-item">
                    <span>Mixed Classification Stores:</span>
                    <span id="mixedStores" class="metric-value">0</span>
                </div>
                <div class="metric-item">
                    <span>Data Asset Copies:</span>
                    <span id="dataCopies" class="metric-value">1</span>
                </div>
                <div class="metric-item">
                    <span>Management Complexity:</span>
                    <span id="managementComplexity" class="metric-value">LOW</span>
                </div>
                <div id="warningMessage"></div>
            </div>

            <div class="section">
                <h3>🗄️ Data Stores</h3>
                <button class="add-group-btn" onclick="addNewDataStore()">+ Add Data Store</button>
                
                <div class="form-group">
                    <label>Store Classification Level:</label>
                    <select id="newStoreClassification">
                        <option value="unclassified">📋 Unclassified (Public)</option>
                        <option value="internal">🏢 Internal Only</option>
                        <option value="confidential" selected>🔐 Confidential</option>
                        <option value="restricted">🚫 Restricted</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Store Name:</label>
                    <input type="text" id="newStoreName" placeholder="e.g., HR Database, Dev Environment">
                </div>
                
                <div id="storeErrorMessage" class="error-message"></div>
                <div id="storeSuccessMessage" class="success-message"></div>
                
                <p style="font-size: 0.8em; color: #ccc; margin-bottom: 15px;">
                    💡 Tip: Drag assets between stores. Ctrl+drag to separate asset into new store.
                </p>
            </div>

            <div class="section">
                <h3>👥 Access Groups</h3>
                <button class="add-group-btn" onclick="addNewGroup()">+ Add Access Group</button>
                
                <div class="preset-buttons">
                    <button class="preset-btn" onclick="addPresetGroup('executives')">👔 Executives</button>
                    <button class="preset-btn" onclick="addPresetGroup('allstaff')">🏢 All Staff</button>
                    <button class="preset-btn" onclick="addPresetGroup('itteam')">💻 IT Team</button>
                    <button class="preset-btn" onclick="addPresetGroup('contractors')">🤝 Contractors</button>
                </div>

                <div id="accessGroups" class="access-groups">
                    <!-- Groups will be dynamically added here -->
                </div>
            </div>

            <div class="section">
                <h3>📤 Data Movement Operations</h3>
                <p style="font-size: 0.8em; color: #ccc; margin-bottom: 10px;">
                    Simulate common data operations that can lead to PoLP violations:
                </p>
                <div class="movement-buttons">
                    <button onclick="addDataMovement('backup')">📦 Create Backup</button>
                    <button onclick="addDataMovement('sharing')">🤝 Share with Team</button>
                    <button onclick="addDataMovement('analytics')">📈 Analytics Copy</button>
                    <button onclick="addDataMovement('development')">💻 Dev/Test Copy</button>
                    <button onclick="addDataMovement('cloud')">☁️ Cloud Migration</button>
                    <button onclick="addDataMovement('partner')">🔗 Partner Access</button>
                </div>
            </div>

            <div class="section">
                <h3>🎛️ Actions</h3>
                <button class="add-group-btn" onclick="loadDemo()" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); margin-bottom: 10px;">🎯 Load PoLP Demo Scenario</button>
                <button onclick="exportConfiguration()" style="background: linear-gradient(135deg, #3742fa 0%, #2f3542 100%); width: 100%; margin-bottom: 5px;">💾 Export Configuration</button>
                <button onclick="document.getElementById('importFile').click()" style="background: linear-gradient(135deg, #2ed573 0%, #1e3799 100%); width: 100%; margin-bottom: 10px;">📂 Import Configuration</button>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importConfiguration(event)">
                <button class="reset-btn" onclick="resetVisualization()">🔄 Reset to Single Asset</button>
            </div>
        </div>

        <div class="visualization">
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()" title="Zoom In (+)">+</button>
                <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out (-)">−</button>
                <button class="zoom-btn" onclick="resetZoom()" title="Reset Zoom (0)">⌂</button>
            </div>
            
            <div id="assetControls" class="asset-controls">
                <button class="close-controls" onclick="closeAssetControls()">×</button>
                <h4 id="assetControlsTitle">Asset Configuration</h4>
                
                <div class="form-group">
                    <label>Asset Name:</label>
                    <input type="text" id="assetName" onchange="updateSelectedAsset('label', this.value)">
                </div>
                
                <div class="form-group">
                    <label>Classification:</label>
                    <select id="assetClassification" onchange="updateSelectedAsset('classification', this.value)">
                        <option value="unclassified">📋 Unclassified</option>
                        <option value="internal">🏢 Internal</option>
                        <option value="confidential">🔐 Confidential</option>
                        <option value="restricted">🚫 Restricted</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Access Groups:</label>
                    <div id="assetAccessGroups" class="checkbox-group">
                        <!-- Checkboxes will be populated here -->
                    </div>
                </div>
                
                <button onclick="separateAsset()" style="background: #f39c12; width: 100%; margin-bottom: 5px;">📤 Separate to New Store</button>
                <button onclick="deleteSelectedAsset()" style="background: #ff4757; width: 100%;">🗑️ Delete Asset</button>
            </div>
            
            <div id="tooltip" class="tooltip"></div>
            <svg id="networkSvg"></svg>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #2ecc71;"></div>
                    <span>📋 Unclassified</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #3498db;"></div>
                    <span>🏢 Internal</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f39c12;"></div>
                    <span>🔐 Confidential</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #e74c3c;"></div>
                    <span>🚫 Restricted</span>
                </div>
                <div style="margin-top: 10px; font-size: 0.8em;">
                    <div>⚠️ = PoLP Violation</div>
                    <div>🔥 = Critical Risk</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Clean, simplified PoLP Visualizer implementation
        class PolpVisualizer {
            constructor() {
                // Core data structures
                this.stores = new Map();
                this.assets = new Map();
                this.groups = new Map();
                this.links = new Map();
                
                // Counters for unique IDs
                this.nextStoreId = 1;
                this.nextAssetId = 1;
                this.nextGroupId = 1;
                this.nextLinkId = 1;
                
                // UI state
                this.selectedAssetId = null;
                
                // D3 setup
                this.setupD3();
                
                // Configuration
                this.setupConstants();
                
                // Initialize with basic data
                this.initialize();
            }
            
            setupD3() {
                this.svg = d3.select('#networkSvg');
                this.width = window.innerWidth - 380;
                this.height = window.innerHeight;
                
                this.svg.attr('width', this.width).attr('height', this.height);
                
                this.zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        this.g.attr('transform', event.transform);
                    });
                
                this.svg.call(this.zoom);
                this.g = this.svg.append('g');
            }
            
            setupConstants() {
                this.groupColors = [
                    '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', 
                    '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43'
                ];
                
                this.classificationColors = {
                    unclassified: '#2ecc71',
                    internal: '#3498db', 
                    confidential: '#f39c12',
                    restricted: '#e74c3c'
                };
                
                this.classificationIcons = {
                    unclassified: '📋',
                    internal: '🏢',
                    confidential: '🔐',
                    restricted: '🚫'
                };
                
                this.classificationLevels = {
                    unclassified: 0,
                    internal: 1,
                    confidential: 2,
                    restricted: 3
                };
                
                this.accessLevels = {
                    individual: { people: 1, complexity: 1 },
                    team: { people: 8, complexity: 2 },
                    department: { people: 25, complexity: 4 },
                    company: { people: 150, complexity: 8 },
                    external: { people: 10, complexity: 6 }
                };
                
                this.presetGroups = {
                    executives: {
                        name: 'Executive Team',
                        access: 'team',
                        permission: 'admin',
                        location: 'anywhere',
                        duration: 'permanent'
                    },
                    allstaff: {
                        name: 'All Staff',
                        access: 'company',
                        permission: 'read',
                        location: 'office',
                        duration: 'permanent'
                    },
                    itteam: {
                        name: 'IT Team',
                        access: 'team',
                        permission: 'admin',
                        location: 'office',
                        duration: 'permanent'
                    },
                    contractors: {
                        name: 'External Contractors',
                        access: 'external',
                        permission: 'read',
                        location: 'vpn',
                        duration: 'temporary'
                    }
                };
                
                this.movementTemplates = {
                    backup: { label: 'Backup Copy', classification: 'confidential' },
                    sharing: { label: 'Shared Copy', classification: 'internal' },
                    analytics: { label: 'Analytics Copy', classification: 'internal' },
                    development: { label: 'Dev Copy', classification: 'unclassified' },
                    cloud: { label: 'Cloud Copy', classification: 'confidential' },
                    partner: { label: 'Partner Copy', classification: 'internal' }
                };
            }
            
            // Core data management
            createStore(label, classification, x = null, y = null) {
                const id = `store_${this.nextStoreId++}`;
                const store = {
                    id,
                    label,
                    classification,
                    x: x || Math.random() * (this.width * 0.6) + (this.width * 0.2),
                    y: y || Math.random() * (this.height * 0.6) + (this.height * 0.2),
                    assetIds: new Set()
                };
                this.stores.set(id, store);
                return store;
            }
            
            createAsset(label, classification, storeId, accessGroups = []) {
                const id = `asset_${this.nextAssetId++}`;
                const store = this.stores.get(storeId);
                
                const asset = {
                    id,
                    label,
                    classification,
                    storeId,
                    accessGroups: new Set(accessGroups),
                    x: store ? store.x : this.width / 2,
                    y: store ? store.y : this.height / 2,
                    isOriginal: true
                };
                
                this.assets.set(id, asset);
                
                if (store) {
                    store.assetIds.add(id);
                    this.positionAssetsInStore(store);
                }
                
                return asset;
            }
            
            createGroup(name, access, permission, location, duration, color = null) {
                const id = `group_${this.nextGroupId++}`;
                const group = {
                    id,
                    name,
                    access,
                    permission,
                    location,
                    duration,
                    color: color || this.groupColors[(this.nextGroupId - 2) % this.groupColors.length]
                };
                this.groups.set(id, group);
                return group;
            }
            
            createLink(sourceId, targetId, type = 'copy') {
                const id = `link_${this.nextLinkId++}`;
                const link = {
                    id,
                    sourceId,
                    targetId,
                    type
                };
                this.links.set(id, link);
                return link;
            }
            
            // Asset positioning
            positionAssetsInStore(store) {
                const assetIds = Array.from(store.assetIds);
                const assets = assetIds.map(id => this.assets.get(id)).filter(Boolean);
                
                if (assets.length === 0) return;
                
                if (assets.length === 1) {
                    assets[0].x = store.x;
                    assets[0].y = store.y;
                } else {
                    const assetsPerRow = Math.ceil(Math.sqrt(assets.length));
                    const spacing = 80;
                    const startX = store.x - ((assetsPerRow - 1) * spacing) / 2;
                    const startY = store.y - (Math.ceil(assets.length / assetsPerRow - 1) * spacing) / 2;
                    
                    assets.forEach((asset, index) => {
                        const row = Math.floor(index / assetsPerRow);
                        const col = index % assetsPerRow;
                        asset.x = startX + col * spacing;
                        asset.y = startY + row * spacing;
                    });
                }
            }
            
            getStoreSize(store) {
                const assetCount = store.assetIds.size;
                const baseWidth = 220;
                const baseHeight = 160;
                
                if (assetCount <= 1) {
                    return { width: baseWidth, height: baseHeight };
                }
                
                const assetsPerRow = Math.ceil(Math.sqrt(assetCount));
                const rows = Math.ceil(assetCount / assetsPerRow);
                const spacing = 80;
                const padding = 60;
                
                const width = Math.max(baseWidth, assetsPerRow * spacing + padding);
                const height = Math.max(baseHeight, rows * spacing + padding);
                
                return { width, height };
            }
            
            // Movement operations (FIXED IMPLEMENTATION)
            addDataMovement(type) {
                const template = this.movementTemplates[type];
                if (!template) return;
                
                // Get only original assets (not copies)
                const originalAssets = Array.from(this.assets.values()).filter(a => a.isOriginal);
                
                if (originalAssets.length === 0) {
                    this.showMessage('No original assets to copy', 'error');
                    return;
                }
                
                // Create new store for copies
                const newStore = this.createStore(`${template.label} Store`, template.classification);
                
                // Create copies of original assets (without modifying originals)
                originalAssets.forEach(originalAsset => {
                    // Create a completely new asset object
                    const copyAsset = this.createAsset(
                        `${originalAsset.label} (${template.label})`,
                        template.classification,
                        newStore.id,
                        Array.from(originalAsset.accessGroups) // Copy access groups
                    );
                    
                    // Mark as copy and track source
                    copyAsset.isOriginal = false;
                    copyAsset.sourceAssetId = originalAsset.id;
                    
                    // Create visual link
                    this.createLink(originalAsset.id, copyAsset.id, 'copy');
                });
                
                this.updateVisualization();
                this.showMessage(`${template.label} created with ${originalAssets.length} copies. Originals preserved.`, 'success');
            }
            
            // Store management
            addNewDataStore() {
                const classification = document.getElementById('newStoreClassification').value;
                let name = document.getElementById('newStoreName').value.trim();
                
                if (!name) {
                    name = `${classification.charAt(0).toUpperCase() + classification.slice(1)} Store ${this.nextStoreId}`;
                }
                
                // Validate store name
                const existingStore = Array.from(this.stores.values()).find(s => 
                    s.label.toLowerCase() === name.toLowerCase()
                );
                
                if (existingStore) {
                    this.showMessage('A store with this name already exists', 'error');
                    return;
                }
                
                // Create store with initial asset
                const store = this.createStore(name, classification);
                this.createAsset('Data Asset', classification, store.id);
                
                // Clear input
                document.getElementById('newStoreName').value = '';
                
                this.updateVisualization();
                this.showMessage(`Store "${name}" created successfully`, 'success');
            }
            
            // Group management
            addNewGroup() {
                const group = this.createGroup(
                    `Access Group ${this.nextGroupId - 1}`,
                    'individual',
                    'read',
                    'office',
                    'temporary'
                );
                this.renderAccessGroups();
                this.updateVisualization();
            }
            
            addPresetGroup(presetType) {
                const preset = this.presetGroups[presetType];
                if (!preset) return;
                
                const group = this.createGroup(
                    preset.name,
                    preset.access,
                    preset.permission,
                    preset.location,
                    preset.duration
                );
                this.renderAccessGroups();
                this.updateVisualization();
            }
            
            deleteGroup(groupId) {
                this.groups.delete(groupId);
                
                // Remove group from all assets
                this.assets.forEach(asset => {
                    asset.accessGroups.delete(groupId);
                });
                
                this.renderAccessGroups();
                this.updateVisualization();
            }
            
            updateGroupProperty(groupId, property, value) {
                const group = this.groups.get(groupId);
                if (!group) return;
                
                if (property === 'name') {
                    if (!value || value.trim().length === 0) {
                        this.showMessage('Group name cannot be empty', 'error');
                        this.renderAccessGroups();
                        return;
                    }
                    
                    const trimmedValue = value.trim();
                    const existingGroup = Array.from(this.groups.values()).find(g => 
                        g.id !== groupId && g.name.toLowerCase() === trimmedValue.toLowerCase()
                    );
                    
                    if (existingGroup) {
                        this.showMessage('A group with this name already exists', 'error');
                        this.renderAccessGroups();
                        return;
                    }
                    
                    group[property] = trimmedValue;
                } else {
                    group[property] = value;
                }
                
                this.updateVisualization();
            }
            
            renderAccessGroups() {
                const container = document.getElementById('accessGroups');
                container.innerHTML = '';
                
                this.groups.forEach(group => {
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'group-item';
                    groupDiv.innerHTML = `
                        <div class="group-header">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div class="group-color" style="background-color: ${group.color};"></div>
                                <input type="text" value="${group.name}" 
                                       onchange="visualizer.updateGroupProperty('${group.id}', 'name', this.value)"
                                       style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); 
                                              border-radius: 3px; padding: 2px 6px; color: #fff; font-size: 0.85em; 
                                              font-weight: bold; width: 140px;">
                            </div>
                            <button class="delete-group" onclick="visualizer.deleteGroup('${group.id}')">×</button>
                        </div>
                        <div class="group-controls">
                            <select onchange="visualizer.updateGroupProperty('${group.id}', 'access', this.value)">
                                <option value="individual" ${group.access === 'individual' ? 'selected' : ''}>Individual</option>
                                <option value="team" ${group.access === 'team' ? 'selected' : ''}>Team</option>
                                <option value="department" ${group.access === 'department' ? 'selected' : ''}>Department</option>
                                <option value="company" ${group.access === 'company' ? 'selected' : ''}>Company</option>
                                <option value="external" ${group.access === 'external' ? 'selected' : ''}>External</option>
                            </select>
                            <select onchange="visualizer.updateGroupProperty('${group.id}', 'permission', this.value)">
                                <option value="read" ${group.permission === 'read' ? 'selected' : ''}>Read</option>
                                <option value="edit" ${group.permission === 'edit' ? 'selected' : ''}>Edit</option>
                                <option value="admin" ${group.permission === 'admin' ? 'selected' : ''}>Admin</option>
                            </select>
                            <select onchange="visualizer.updateGroupProperty('${group.id}', 'location', this.value)">
                                <option value="office" ${group.location === 'office' ? 'selected' : ''}>Office</option>
                                <option value="vpn" ${group.location === 'vpn' ? 'selected' : ''}>VPN</option>
                                <option value="anywhere" ${group.location === 'anywhere' ? 'selected' : ''}>Anywhere</option>
                            </select>
                            <select onchange="visualizer.updateGroupProperty('${group.id}', 'duration', this.value)">
                                <option value="temporary" ${group.duration === 'temporary' ? 'selected' : ''}>Temporary</option>
                                <option value="project" ${group.duration === 'project' ? 'selected' : ''}>Project</option>
                                <option value="permanent" ${group.duration === 'permanent' ? 'selected' : ''}>Permanent</option>
                            </select>
                        </div>
                    `;
                    container.appendChild(groupDiv);
                });
            }
            
            // Asset controls
            showAssetControls(assetId, event) {
                this.selectedAssetId = assetId;
                const asset = this.assets.get(assetId);
                if (!asset) return;
                
                const controls = document.getElementById('assetControls');
                document.getElementById('assetControlsTitle').textContent = `${asset.label} Configuration`;
                document.getElementById('assetName').value = asset.label;
                document.getElementById('assetClassification').value = asset.classification;
                
                // Populate access groups
                const accessGroupsDiv = document.getElementById('assetAccessGroups');
                accessGroupsDiv.innerHTML = '';
                
                this.groups.forEach(group => {
                    const isChecked = asset.accessGroups.has(group.id);
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.className = 'checkbox-item';
                    checkboxDiv.innerHTML = `
                        <input type="checkbox" id="checkbox_${group.id}" ${isChecked ? 'checked' : ''} 
                               onchange="visualizer.toggleAssetAccess('${assetId}', '${group.id}', this.checked)">
                        <label for="checkbox_${group.id}" style="color: ${group.color};">${group.name}</label>
                    `;
                    accessGroupsDiv.appendChild(checkboxDiv);
                });
                
                // Position controls
                const rect = event.target.getBoundingClientRect();
                const left = Math.min(event.pageX + 10, window.innerWidth - 300);
                const top = Math.min(event.pageY + 10, window.innerHeight - 400);
                
                controls.style.left = Math.max(20, left) + 'px';
                controls.style.top = Math.max(20, top) + 'px';
                controls.style.display = 'block';
            }
            
            closeAssetControls() {
                document.getElementById('assetControls').style.display = 'none';
                this.selectedAssetId = null;
            }
            
            updateSelectedAsset(property, value) {
                if (!this.selectedAssetId) return;
                
                const asset = this.assets.get(this.selectedAssetId);
                if (!asset) return;
                
                if (property === 'label' && (!value || value.trim().length === 0)) {
                    this.showMessage('Asset name cannot be empty', 'error');
                    return;
                }
                
                asset[property] = value.trim ? value.trim() : value;
                this.updateVisualization();
            }
            
            toggleAssetAccess(assetId, groupId, isChecked) {
                const asset = this.assets.get(assetId);
                if (!asset) return;
                
                if (isChecked) {
                    asset.accessGroups.add(groupId);
                } else {
                    asset.accessGroups.delete(groupId);
                }
                
                this.updateVisualization();
            }
            
            separateAsset() {
                if (!this.selectedAssetId) return;
                
                const asset = this.assets.get(this.selectedAssetId);
                if (!asset) return;
                
                const currentStore = this.stores.get(asset.storeId);
                if (!currentStore || currentStore.assetIds.size <= 1) {
                    this.showMessage('Cannot separate the only asset from a store', 'error');
                    return;
                }
                
                // Remove from current store
                currentStore.assetIds.delete(this.selectedAssetId);
                this.positionAssetsInStore(currentStore);
                
                // Create new store
                const newStore = this.createStore(`${asset.label} Store`, asset.classification, asset.x + 150, asset.y + 100);
                
                // Move asset to new store
                asset.storeId = newStore.id;
                newStore.assetIds.add(this.selectedAssetId);
                this.positionAssetsInStore(newStore);
                
                this.closeAssetControls();
                this.updateVisualization();
            }
            
            deleteSelectedAsset() {
                if (!this.selectedAssetId) return;
                
                const asset = this.assets.get(this.selectedAssetId);
                if (!asset) return;
                
                const store = this.stores.get(asset.storeId);
                
                // Remove from store
                if (store) {
                    store.assetIds.delete(this.selectedAssetId);
                    
                    // Delete empty store
                    if (store.assetIds.size === 0) {
                        this.stores.delete(store.id);
                    } else {
                        this.positionAssetsInStore(store);
                    }
                }
                
                // Remove asset
                this.assets.delete(this.selectedAssetId);
                
                // Remove associated links
                const linksToDelete = [];
                this.links.forEach((link, id) => {
                    if (link.sourceId === this.selectedAssetId || link.targetId === this.selectedAssetId) {
                        linksToDelete.push(id);
                    }
                });
                linksToDelete.forEach(id => this.links.delete(id));
                
                this.closeAssetControls();
                this.updateVisualization();
                this.showMessage('Asset deleted successfully', 'success');
            }
            
            // Metrics calculation
            calculateMetrics() {
                let totalPeople = 0;
                let classificationViolations = 0;
                let mixedStores = 0;
                let totalComplexity = 0;
                
                // Calculate people with access
                const uniqueGroups = new Set();
                this.assets.forEach(asset => {
                    asset.accessGroups.forEach(groupId => {
                        if (!uniqueGroups.has(groupId)) {
                            uniqueGroups.add(groupId);
                            const group = this.groups.get(groupId);
                            if (group) {
                                totalPeople += this.accessLevels[group.access].people;
                                totalComplexity += this.accessLevels[group.access].complexity;
                            }
                        }
                    });
                });
                
                // Check violations
                this.stores.forEach(store => {
                    const storeAssets = Array.from(store.assetIds).map(id => this.assets.get(id)).filter(Boolean);
                    const classifications = [...new Set(storeAssets.map(a => a.classification))];
                    
                    // Mixed classification store
                    if (classifications.length > 1) {
                        mixedStores++;
                    }
                    
                    // Classification violations
                    storeAssets.forEach(asset => {
                        if (this.classificationLevels[asset.classification] > this.classificationLevels[store.classification]) {
                            classificationViolations++;
                        }
                        
                        // Access violations
                        asset.accessGroups.forEach(groupId => {
                            const group = this.groups.get(groupId);
                            if (group) {
                                if (group.access === 'external' && 
                                    (asset.classification === 'confidential' || asset.classification === 'restricted')) {
                                    classificationViolations++;
                                }
                                if (group.access === 'company' && asset.classification === 'restricted') {
                                    classificationViolations++;
                                }
                            }
                        });
                    });
                });
                
                const complexity = totalComplexity > 50 ? 'CRITICAL' : 
                                 totalComplexity > 25 ? 'HIGH' : 
                                 totalComplexity > 10 ? 'MEDIUM' : 'LOW';
                
                return {
                    totalPeople,
                    classificationViolations,
                    mixedStores,
                    dataCopies: this.assets.size,
                    complexity
                };
            }
            
            updateMetrics() {
                const metrics = this.calculateMetrics();
                
                document.getElementById('totalPeople').textContent = metrics.totalPeople;
                document.getElementById('classificationViolations').textContent = metrics.classificationViolations;
                document.getElementById('mixedStores').textContent = metrics.mixedStores;
                document.getElementById('dataCopies').textContent = metrics.dataCopies;
                document.getElementById('managementComplexity').textContent = metrics.complexity;
                
                // Generate warnings
                let warningMessage = '';
                if (metrics.classificationViolations > 0) {
                    warningMessage += `<div class="critical-warning">🔥 CRITICAL: ${metrics.classificationViolations} classification violation(s) detected!</div>`;
                }
                if (metrics.mixedStores > 0) {
                    warningMessage += `<div class="warning">⚠️ ${metrics.mixedStores} store(s) contain mixed classification data</div>`;
                }
                if (metrics.complexity === 'CRITICAL') {
                    warningMessage += '<div class="critical-warning">🚨 Management complexity is critical!</div>';
                }
                
                document.getElementById('warningMessage').innerHTML = warningMessage;
            }
            
            // Visualization
            updateVisualization() {
                this.updateMetrics();
                this.drawVisualization();
            }
            
            drawVisualization() {
                this.g.selectAll('*').remove();
                
                // Position assets in stores
                this.stores.forEach(store => {
                    this.positionAssetsInStore(store);
                });
                
                // Draw stores
                const storeData = Array.from(this.stores.values());
                const storeSelection = this.g.selectAll('.store')
                    .data(storeData, d => d.id)
                    .enter().append('g')
                    .attr('class', 'store');
                
                // Store rectangles
                storeSelection.append('rect')
                    .attr('x', d => {
                        const { width } = this.getStoreSize(d);
                        return d.x - width / 2;
                    })
                    .attr('y', d => {
                        const { height } = this.getStoreSize(d);
                        return d.y - height / 2;
                    })
                    .attr('width', d => this.getStoreSize(d).width)
                    .attr('height', d => this.getStoreSize(d).height)
                    .attr('fill', d => {
                        // Check for violations
                        const storeAssets = Array.from(d.assetIds).map(id => this.assets.get(id)).filter(Boolean);
                        const hasViolation = storeAssets.some(asset => 
                            this.classificationLevels[asset.classification] > this.classificationLevels[d.classification]
                        );
                        return hasViolation ? '#ff4757' : this.classificationColors[d.classification];
                    })
                    .attr('stroke', '#ffffff')
                    .attr('stroke-width', 2)
                    .attr('rx', 8)
                    .style('filter', 'drop-shadow(0 3px 6px rgba(0,0,0,0.3))')
                    .style('cursor', 'move')
                    .call(this.createDragBehavior('store'));
                
                // Store labels
                storeSelection.append('text')
                    .attr('x', d => d.x)
                    .attr('y', d => {
                        const { height } = this.getStoreSize(d);
                        return d.y - height / 2 - 10;
                    })
                    .attr('class', 'node-label')
                    .style('font-size', '12px')
                    .text(d => d.label);
                
                // Store icons
                storeSelection.append('text')
                    .attr('x', d => d.x)
                    .attr('y', d => {
                        const { height } = this.getStoreSize(d);
                        return d.y + height / 2 + 20;
                    })
                    .style('font-size', '24px')
                    .style('text-anchor', 'middle')
                    .text(d => this.classificationIcons[d.classification]);
                
                // Draw links
                const linkData = Array.from(this.links.values());
                this.g.selectAll('.link')
                    .data(linkData, d => d.id)
                    .enter().append('line')
                    .attr('class', d => `link ${d.type === 'copy' ? 'copy-link' : ''}`)
                    .attr('x1', d => {
                        const source = this.assets.get(d.sourceId);
                        return source ? source.x : 0;
                    })
                    .attr('y1', d => {
                        const source = this.assets.get(d.sourceId);
                        return source ? source.y : 0;
                    })
                    .attr('x2', d => {
                        const target = this.assets.get(d.targetId);
                        return target ? target.x : 0;
                    })
                    .attr('y2', d => {
                        const target = this.assets.get(d.targetId);
                        return target ? target.y : 0;
                    });
                
                // Draw access group halos
                this.groups.forEach(group => {
                    const groupAssets = Array.from(this.assets.values()).filter(a => a.accessGroups.has(group.id));
                    if (groupAssets.length > 0) {
                        this.g.selectAll(`.halo-${group.id}`)
                            .data(groupAssets)
                            .enter().append('circle')
                            .attr('class', `halo-${group.id}`)
                            .attr('cx', d => d.x)
                            .attr('cy', d => d.y)
                            .attr('r', 40)
                            .attr('fill', group.color)
                            .attr('opacity', 0.1)
                            .attr('stroke', group.color)
                            .attr('stroke-width', 1)
                            .attr('stroke-opacity', 0.3);
                    }
                });
                
                // Draw assets
                const assetData = Array.from(this.assets.values());
                const assetSelection = this.g.selectAll('.asset')
                    .data(assetData, d => d.id)
                    .enter().append('g')
                    .attr('class', 'asset');
                
                // Asset circles
                assetSelection.append('circle')
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('r', 18)
                    .attr('fill', d => {
                        const store = this.stores.get(d.storeId);
                        const hasViolation = store && 
                            this.classificationLevels[d.classification] > this.classificationLevels[store.classification];
                        return hasViolation ? '#ff4757' : this.classificationColors[d.classification];
                    })
                    .attr('stroke', '#ffffff')
                    .attr('stroke-width', 3)
                    .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.3))')
                    .style('cursor', 'move')
                    .on('click', (event, d) => {
                        event.stopPropagation();
                        this.showAssetControls(d.id, event);
                    })
                    .call(this.createDragBehavior('asset'));
                
                // Asset labels
                assetSelection.append('text')
                    .attr('x', d => d.x)
                    .attr('y', d => d.y + 35)
                    .attr('class', 'node-label')
                    .style('font-size', '10px')
                    .text(d => d.label);
                
                // Asset icons
                assetSelection.append('text')
                    .attr('x', d => d.x)
                    .attr('y', d => d.y + 3)
                    .style('font-size', '12px')
                    .style('text-anchor', 'middle')
                    .text(d => this.classificationIcons[d.classification]);
                
                // Add violation indicators
                this.addViolationIndicators();
            }
            
            addViolationIndicators() {
                const violations = [];
                
                this.assets.forEach(asset => {
                    const store = this.stores.get(asset.storeId);
                    if (store && this.classificationLevels[asset.classification] > this.classificationLevels[store.classification]) {
                        violations.push({
                            x: asset.x + 25,
                            y: asset.y - 20,
                            type: 'classification'
                        });
                    }
                });
                
                this.g.selectAll('.violation-indicator')
                    .data(violations)
                    .enter().append('text')
                    .attr('class', 'violation-indicator')
                    .attr('x', d => d.x)
                    .attr('y', d => d.y)
                    .style('font-size', '16px')
                    .style('cursor', 'pointer')
                    .text('⚠️');
            }
            
            createDragBehavior(type) {
                return d3.drag()
                    .on('start', (event, d) => this.dragStarted(event, d))
                    .on('drag', (event, d) => type === 'store' ? this.draggedStore(event, d) : this.draggedAsset(event, d))
                    .on('end', (event, d) => this.dragEnded(event, d));
            }
            
            dragStarted(event, d) {
                d.isDragging = true;
                d.dragOffsetX = event.x - d.x;
                d.dragOffsetY = event.y - d.y;
            }
            
            draggedStore(event, d) {
                const newX = event.x - d.dragOffsetX;
                const newY = event.y - d.dragOffsetY;
                
                const { width, height } = this.getStoreSize(d);
                const margin = Math.max(50, width / 2, height / 2);
                
                d.x = Math.max(width/2 + margin, Math.min(this.width - width/2 - margin, newX));
                d.y = Math.max(height/2 + margin, Math.min(this.height - height/2 - margin, newY));
                
                this.positionAssetsInStore(d);
                this.updatePositions();
            }
            
            draggedAsset(event, d) {
                const newX = event.x - d.dragOffsetX;
                const newY = event.y - d.dragOffsetY;
                
                const margin = 30;
                d.x = Math.max(margin, Math.min(this.width - margin, newX));
                d.y = Math.max(margin, Math.min(this.height - margin, newY));
                
                // Highlight potential drop targets
                this.g.selectAll('rect').attr('stroke', '#ffffff').attr('stroke-width', 2);
                
                const targetStore = Array.from(this.stores.values()).find(store => {
                    if (store.id === d.storeId) return false;
                    const { width, height } = this.getStoreSize(store);
                    const dx = Math.abs(store.x - d.x);
                    const dy = Math.abs(store.y - d.y);
                    return dx < width / 2 && dy < height / 2;
                });
                
                if (targetStore) {
                    this.g.selectAll('rect')
                        .filter(storeData => storeData.id === targetStore.id)
                        .attr('stroke', '#00d4aa')
                        .attr('stroke-width', 4);
                }
                
                this.updatePositions();
            }
            
            dragEnded(event, d) {
                if (!d.isDragging) return;
                d.isDragging = false;
                
                this.g.selectAll('rect').attr('stroke', '#ffffff').attr('stroke-width', 2);
                
                if (d.storeId) { // This is an asset
                    const targetStore = Array.from(this.stores.values()).find(store => {
                        if (store.id === d.storeId) return false;
                        const { width, height } = this.getStoreSize(store);
                        const dx = Math.abs(store.x - d.x);
                        const dy = Math.abs(store.y - d.y);
                        return dx < width / 2 && dy < height / 2;
                    });
                    
                    if (targetStore) {
                        // Move asset to new store
                        const oldStore = this.stores.get(d.storeId);
                        if (oldStore) {
                            oldStore.assetIds.delete(d.id);
                            if (oldStore.assetIds.size === 0) {
                                this.stores.delete(oldStore.id);
                            } else {
                                this.positionAssetsInStore(oldStore);
                            }
                        }
                        
                        targetStore.assetIds.add(d.id);
                        d.storeId = targetStore.id;
                        this.positionAssetsInStore(targetStore);
                        
                        this.updateVisualization();
                        this.showMessage(`Moved "${d.label}" to "${targetStore.label}"`, 'success');
                    } else {
                        // Snap back to original store
                        const originalStore = this.stores.get(d.storeId);
                        if (originalStore) {
                            this.positionAssetsInStore(originalStore);
                        }
                        this.updatePositions();
                    }
                } else {
                    // Store was dragged
                    this.positionAssetsInStore(d);
                    this.updatePositions();
                }
                
                delete d.dragOffsetX;
                delete d.dragOffsetY;
            }
            
            updatePositions() {
                // Update store positions
                this.g.selectAll('.store')
                    .select('rect')
                    .attr('x', d => {
                        const { width } = this.getStoreSize(d);
                        return d.x - width / 2;
                    })
                    .attr('y', d => {
                        const { height } = this.getStoreSize(d);
                        return d.y - height / 2;
                    })
                    .attr('width', d => this.getStoreSize(d).width)
                    .attr('height', d => this.getStoreSize(d).height);
                
                // Update store labels
                this.g.selectAll('.store')
                    .select('text:first-of-type')
                    .attr('x', d => d.x)
                    .attr('y', d => {
                        const { height } = this.getStoreSize(d);
                        return d.y - height / 2 - 10;
                    });
                
                // Update store icons
                this.g.selectAll('.store')
                    .select('text:last-of-type')
                    .attr('x', d => d.x)
                    .attr('y', d => {
                        const { height } = this.getStoreSize(d);
                        return d.y + height / 2 + 20;
                    });
                
                // Update asset positions
                this.g.selectAll('.asset')
                    .select('circle')
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                this.g.selectAll('.asset')
                    .select('text.node-label')
                    .attr('x', d => d.x)
                    .attr('y', d => d.y + 35);
                
                this.g.selectAll('.asset')
                    .select('text:not(.node-label)')
                    .attr('x', d => d.x)
                    .attr('y', d => d.y + 3);
                
                // Update access group halos
                this.groups.forEach(group => {
                    this.g.selectAll(`.halo-${group.id}`)
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y);
                });
                
                // Update links
                this.g.selectAll('.link')
                    .attr('x1', d => {
                        const source = this.assets.get(d.sourceId);
                        return source ? source.x : 0;
                    })
                    .attr('y1', d => {
                        const source = this.assets.get(d.sourceId);
                        return source ? source.y : 0;
                    })
                    .attr('x2', d => {
                        const target = this.assets.get(d.targetId);
                        return target ? target.x : 0;
                    })
                    .attr('y2', d => {
                        const target = this.assets.get(d.targetId);
                        return target ? target.y : 0;
                    });
            }
            
            // Demo scenario
            loadDemo() {
                // Clear existing data
                this.stores.clear();
                this.assets.clear();
                this.groups.clear();
                this.links.clear();
                this.nextStoreId = 1;
                this.nextAssetId = 1;
                this.nextGroupId = 1;
                this.nextLinkId = 1;
                
                // Create access groups
                const executivesGroup = this.createGroup('Executive Team', 'team', 'admin', 'anywhere', 'permanent');
                const allStaffGroup = this.createGroup('All Staff', 'company', 'read', 'office', 'permanent');
                const hrGroup = this.createGroup('HR Department', 'department', 'edit', 'office', 'permanent');
                const contractorsGroup = this.createGroup('External Contractors', 'external', 'read', 'anywhere', 'temporary');
                const devsGroup = this.createGroup('Development Team', 'team', 'admin', 'vpn', 'project');
                
                // Create stores with violations
                const mixedStore = this.createStore('Legacy Mixed Database', 'internal', 200, 200);
                const devStore = this.createStore('Development Environment', 'unclassified', 500, 200);
                const backupStore = this.createStore('Cloud Backup', 'confidential', 350, 400);
                const secureStore = this.createStore('Secure HR Vault', 'restricted', 650, 350);
                
                // Create assets with violations
                const payrollAsset = this.createAsset('Employee Payroll Data', 'restricted', mixedStore.id, [hrGroup.id, allStaffGroup.id]);
                const publicAsset = this.createAsset('Company Newsletter', 'unclassified', mixedStore.id, [allStaffGroup.id]);
                const customerDevAsset = this.createAsset('Customer Data (Dev Copy)', 'confidential', devStore.id, [devsGroup.id, contractorsGroup.id]);
                const backupAsset = this.createAsset('Full System Backup', 'restricted', backupStore.id, [executivesGroup.id, allStaffGroup.id, contractorsGroup.id]);
                const secureHRAsset = this.createAsset('Secure Employee Records', 'restricted', secureStore.id, [hrGroup.id]);
                
                // Create problematic links
                this.createLink(payrollAsset.id, customerDevAsset.id, 'copy');
                this.createLink(payrollAsset.id, backupAsset.id, 'copy');
                
                this.renderAccessGroups();
                this.updateVisualization();
                this.showMessage('Demo scenario loaded with multiple PoLP violations', 'success');
            }
            
            // Utility functions
            showMessage(message, type = 'error') {
                const container = type === 'success' ? 
                    document.getElementById('storeSuccessMessage') : 
                    document.getElementById('storeErrorMessage');
                
                // Clear both containers
                document.getElementById('storeErrorMessage').style.display = 'none';
                document.getElementById('storeSuccessMessage').style.display = 'none';
                
                container.textContent = message;
                container.style.display = 'block';
                
                setTimeout(() => {
                    container.style.display = 'none';
                }, 3000);
            }
            
            zoomIn() {
                this.svg.transition().duration(300).call(this.zoom.scaleBy, 1.5);
            }
            
            zoomOut() {
                this.svg.transition().duration(300).call(this.zoom.scaleBy, 1 / 1.5);
            }
            
            resetZoom() {
                this.svg.transition().duration(500).call(this.zoom.transform, d3.zoomIdentity);
            }
            
            resetVisualization() {
                this.stores.clear();
                this.assets.clear();
                this.groups.clear();
                this.links.clear();
                this.nextStoreId = 1;
                this.nextAssetId = 1;
                this.nextGroupId = 1;
                this.nextLinkId = 1;
                
                this.closeAssetControls();
                this.initialize();
                this.showMessage('Visualization reset to initial state', 'success');
            }
            
            exportConfiguration() {
                const config = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    stores: Array.from(this.stores.values()),
                    assets: Array.from(this.assets.values()).map(asset => ({
                        ...asset,
                        accessGroups: Array.from(asset.accessGroups)
                    })),
                    groups: Array.from(this.groups.values()),
                    links: Array.from(this.links.values()),
                    counters: {
                        nextStoreId: this.nextStoreId,
                        nextAssetId: this.nextAssetId,
                        nextGroupId: this.nextGroupId,
                        nextLinkId: this.nextLinkId
                    }
                };
                
                const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `polp-configuration-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.showMessage('Configuration exported successfully', 'success');
            }
            
            importConfiguration(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const config = JSON.parse(e.target.result);
                        
                        // Clear existing data
                        this.stores.clear();
                        this.assets.clear();
                        this.groups.clear();
                        this.links.clear();
                        
                        // Import stores
                        if (config.stores) {
                            config.stores.forEach(store => {
                                store.assetIds = new Set(store.assetIds || []);
                                this.stores.set(store.id, store);
                            });
                        }
                        
                        // Import assets
                        if (config.assets) {
                            config.assets.forEach(asset => {
                                asset.accessGroups = new Set(asset.accessGroups || []);
                                this.assets.set(asset.id, asset);
                            });
                        }
                        
                        // Import groups
                        if (config.groups) {
                            config.groups.forEach(group => {
                                this.groups.set(group.id, group);
                            });
                        }
                        
                        // Import links
                        if (config.links) {
                            config.links.forEach(link => {
                                this.links.set(link.id, link);
                            });
                        }
                        
                        // Import counters
                        if (config.counters) {
                            this.nextStoreId = config.counters.nextStoreId || 1;
                            this.nextAssetId = config.counters.nextAssetId || 1;
                            this.nextGroupId = config.counters.nextGroupId || 1;
                            this.nextLinkId = config.counters.nextLinkId || 1;
                        }
                        
                        this.renderAccessGroups();
                        this.updateVisualization();
                        this.showMessage('Configuration imported successfully', 'success');
                        
                    } catch (error) {
                        this.showMessage(`Import failed: ${error.message}`, 'error');
                    }
                };
                reader.readAsText(file);
                
                event.target.value = '';
            }
            
            // Initialize with basic setup
            initialize() {
                const initialStore = this.createStore('Primary Data Store', 'confidential', this.width / 2, this.height / 2);
                this.createAsset('Sensitive Customer Data', 'confidential', initialStore.id);
                
                this.updateVisualization();
            }
        }
        
        // Global instance
        let visualizer;
        
        // Global functions for onclick handlers
        function addNewDataStore() { visualizer.addNewDataStore(); }
        function addNewGroup() { visualizer.addNewGroup(); }
        function addPresetGroup(type) { visualizer.addPresetGroup(type); }
        function addDataMovement(type) { visualizer.addDataMovement(type); }
        function loadDemo() { visualizer.loadDemo(); }
        function resetVisualization() { visualizer.resetVisualization(); }
        function exportConfiguration() { visualizer.exportConfiguration(); }
        function importConfiguration(event) { visualizer.importConfiguration(event); }
        function separateAsset() { visualizer.separateAsset(); }
        function deleteSelectedAsset() { visualizer.deleteSelectedAsset(); }
        function updateSelectedAsset(property, value) { visualizer.updateSelectedAsset(property, value); }
        function closeAssetControls() { visualizer.closeAssetControls(); }
        function toggleAssetAccess(assetId, groupId, isChecked) { visualizer.toggleAssetAccess(assetId, groupId, isChecked); }
        function zoomIn() { visualizer.zoomIn(); }
        function zoomOut() { visualizer.zoomOut(); }
        function resetZoom() { visualizer.resetZoom(); }
        
        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            visualizer = new PolpVisualizer();
            
            // Global click handler
            document.addEventListener('click', (event) => {
                if (!event.target.closest('.asset-controls') && !event.target.closest('.asset')) {
                    visualizer.closeAssetControls();
                }
            });
            
            // Window resize handler
            window.addEventListener('resize', () => {
                visualizer.width = window.innerWidth - 380;
                visualizer.height = window.innerHeight;
                visualizer.svg.attr('width', visualizer.width).attr('height', visualizer.height);
                visualizer.closeAssetControls();
            });
        });
    </script>
</body>
</html>